{"ast":null,"code":"import _isPlainObject from \"lodash/isPlainObject\";\nimport _isFunction from \"lodash/isFunction\";\nimport _includes from \"lodash/includes\";\nimport Helpers from \"./helpers\";\nimport Collection from \"./collection\";\nimport * as d3Scale from \"d3-scale\";\nvar supportedScaleStrings = [\"linear\", \"time\", \"log\", \"sqrt\"]; // Private Functions\n\nfunction toNewName(scale) {\n  // d3 scale changed the naming scheme for scale from \"linear\" -> \"scaleLinear\" etc.\n  var capitalize = function capitalize(s) {\n    return s && s[0].toUpperCase() + s.slice(1);\n  };\n  return \"scale\".concat(capitalize(scale));\n}\nfunction validScale(scale) {\n  if (typeof scale === \"function\") {\n    return _isFunction(scale.copy) && _isFunction(scale.domain) && _isFunction(scale.range);\n  } else if (typeof scale === \"string\") {\n    return _includes(supportedScaleStrings, scale);\n  }\n  return false;\n}\nfunction isScaleDefined(props, axis) {\n  if (!props.scale) {\n    return false;\n  } else if (props.scale.x || props.scale.y) {\n    return props.scale[axis] ? true : false;\n  }\n  return true;\n}\nfunction getScaleTypeFromProps(props, axis) {\n  if (!isScaleDefined(props, axis)) {\n    return undefined;\n  }\n  var scale = props.scale[axis] || props.scale;\n  return typeof scale === \"string\" ? scale : getType(scale);\n}\nfunction getScaleFromDomain(props, axis) {\n  var domain;\n  if (props.domain && props.domain[axis]) {\n    domain = props.domain[axis];\n  } else if (props.domain && Array.isArray(props.domain)) {\n    domain = props.domain;\n  }\n  if (!domain) {\n    return undefined;\n  }\n  return Collection.containsDates(domain) ? \"time\" : \"linear\";\n}\nfunction getScaleTypeFromData(props, axis) {\n  if (!props.data) {\n    return \"linear\";\n  }\n  var accessor = Helpers.createAccessor(props[axis]);\n  var axisData = props.data.map(function (datum) {\n    var processedData = _isPlainObject(accessor(datum)) ? accessor(datum)[axis] : accessor(datum);\n    return processedData !== undefined ? processedData : datum[axis];\n  });\n  return Collection.containsDates(axisData) ? \"time\" : \"linear\";\n} // Exported Functions\n\nfunction getScaleFromName(name) {\n  return validScale(name) ? d3Scale[toNewName(name)]() : d3Scale.scaleLinear();\n}\nfunction getBaseScale(props, axis) {\n  var scale = getScaleFromProps(props, axis);\n  if (scale) {\n    return typeof scale === \"string\" ? getScaleFromName(scale) : scale;\n  }\n  var defaultScale = getScaleFromDomain(props, axis) || getScaleTypeFromData(props, axis);\n  return d3Scale[toNewName(defaultScale)]();\n}\nfunction getDefaultScale() {\n  return d3Scale.scaleLinear();\n}\nfunction getScaleFromProps(props, axis) {\n  if (!isScaleDefined(props, axis)) {\n    return undefined;\n  }\n  var scale = props.scale[axis] || props.scale;\n  if (validScale(scale)) {\n    return _isFunction(scale) ? scale : d3Scale[toNewName(scale)]();\n  }\n  return undefined;\n}\nfunction getScaleType(props, axis) {\n  // if the scale was not given in props, it will be set to linear or time depending on data\n  return getScaleTypeFromProps(props, axis) || getScaleTypeFromData(props, axis);\n}\nfunction getType(scale) {\n  if (typeof scale === \"string\") {\n    return scale;\n  }\n  var duckTypes = [{\n    name: \"log\",\n    method: \"base\"\n  }, {\n    name: \"ordinal\",\n    method: \"unknown\"\n  }, {\n    name: \"pow-sqrt\",\n    method: \"exponent\"\n  }, {\n    name: \"quantile\",\n    method: \"quantiles\"\n  }, {\n    name: \"quantize-threshold\",\n    method: \"invertExtent\"\n  }];\n  var scaleType = duckTypes.filter(function (type) {\n    return scale[type.method] !== undefined;\n  })[0];\n  return scaleType ? scaleType.name : undefined;\n}\nexport default {\n  getBaseScale: getBaseScale,\n  getDefaultScale: getDefaultScale,\n  getScaleFromProps: getScaleFromProps,\n  getScaleType: getScaleType,\n  getType: getType,\n  getScaleFromName: getScaleFromName\n};","map":{"version":3,"names":["_isPlainObject","_isFunction","_includes","Helpers","Collection","d3Scale","supportedScaleStrings","toNewName","scale","capitalize","s","toUpperCase","slice","concat","validScale","copy","domain","range","isScaleDefined","props","axis","x","y","getScaleTypeFromProps","undefined","getType","getScaleFromDomain","Array","isArray","containsDates","getScaleTypeFromData","data","accessor","createAccessor","axisData","map","datum","processedData","getScaleFromName","name","scaleLinear","getBaseScale","getScaleFromProps","defaultScale","getDefaultScale","getScaleType","duckTypes","method","scaleType","filter","type"],"sources":["/root/experiment/nova-explorer/node_modules/victory-core/es/victory-util/scale.js"],"sourcesContent":["import _isPlainObject from \"lodash/isPlainObject\";\nimport _isFunction from \"lodash/isFunction\";\nimport _includes from \"lodash/includes\";\nimport Helpers from \"./helpers\";\nimport Collection from \"./collection\";\nimport * as d3Scale from \"d3-scale\";\nvar supportedScaleStrings = [\"linear\", \"time\", \"log\", \"sqrt\"]; // Private Functions\n\nfunction toNewName(scale) {\n  // d3 scale changed the naming scheme for scale from \"linear\" -> \"scaleLinear\" etc.\n  var capitalize = function (s) {\n    return s && s[0].toUpperCase() + s.slice(1);\n  };\n\n  return \"scale\".concat(capitalize(scale));\n}\n\nfunction validScale(scale) {\n  if (typeof scale === \"function\") {\n    return _isFunction(scale.copy) && _isFunction(scale.domain) && _isFunction(scale.range);\n  } else if (typeof scale === \"string\") {\n    return _includes(supportedScaleStrings, scale);\n  }\n\n  return false;\n}\n\nfunction isScaleDefined(props, axis) {\n  if (!props.scale) {\n    return false;\n  } else if (props.scale.x || props.scale.y) {\n    return props.scale[axis] ? true : false;\n  }\n\n  return true;\n}\n\nfunction getScaleTypeFromProps(props, axis) {\n  if (!isScaleDefined(props, axis)) {\n    return undefined;\n  }\n\n  var scale = props.scale[axis] || props.scale;\n  return typeof scale === \"string\" ? scale : getType(scale);\n}\n\nfunction getScaleFromDomain(props, axis) {\n  var domain;\n\n  if (props.domain && props.domain[axis]) {\n    domain = props.domain[axis];\n  } else if (props.domain && Array.isArray(props.domain)) {\n    domain = props.domain;\n  }\n\n  if (!domain) {\n    return undefined;\n  }\n\n  return Collection.containsDates(domain) ? \"time\" : \"linear\";\n}\n\nfunction getScaleTypeFromData(props, axis) {\n  if (!props.data) {\n    return \"linear\";\n  }\n\n  var accessor = Helpers.createAccessor(props[axis]);\n  var axisData = props.data.map(function (datum) {\n    var processedData = _isPlainObject(accessor(datum)) ? accessor(datum)[axis] : accessor(datum);\n    return processedData !== undefined ? processedData : datum[axis];\n  });\n  return Collection.containsDates(axisData) ? \"time\" : \"linear\";\n} // Exported Functions\n\n\nfunction getScaleFromName(name) {\n  return validScale(name) ? d3Scale[toNewName(name)]() : d3Scale.scaleLinear();\n}\n\nfunction getBaseScale(props, axis) {\n  var scale = getScaleFromProps(props, axis);\n\n  if (scale) {\n    return typeof scale === \"string\" ? getScaleFromName(scale) : scale;\n  }\n\n  var defaultScale = getScaleFromDomain(props, axis) || getScaleTypeFromData(props, axis);\n  return d3Scale[toNewName(defaultScale)]();\n}\n\nfunction getDefaultScale() {\n  return d3Scale.scaleLinear();\n}\n\nfunction getScaleFromProps(props, axis) {\n  if (!isScaleDefined(props, axis)) {\n    return undefined;\n  }\n\n  var scale = props.scale[axis] || props.scale;\n\n  if (validScale(scale)) {\n    return _isFunction(scale) ? scale : d3Scale[toNewName(scale)]();\n  }\n\n  return undefined;\n}\n\nfunction getScaleType(props, axis) {\n  // if the scale was not given in props, it will be set to linear or time depending on data\n  return getScaleTypeFromProps(props, axis) || getScaleTypeFromData(props, axis);\n}\n\nfunction getType(scale) {\n  if (typeof scale === \"string\") {\n    return scale;\n  }\n\n  var duckTypes = [{\n    name: \"log\",\n    method: \"base\"\n  }, {\n    name: \"ordinal\",\n    method: \"unknown\"\n  }, {\n    name: \"pow-sqrt\",\n    method: \"exponent\"\n  }, {\n    name: \"quantile\",\n    method: \"quantiles\"\n  }, {\n    name: \"quantize-threshold\",\n    method: \"invertExtent\"\n  }];\n  var scaleType = duckTypes.filter(function (type) {\n    return scale[type.method] !== undefined;\n  })[0];\n  return scaleType ? scaleType.name : undefined;\n}\n\nexport default {\n  getBaseScale: getBaseScale,\n  getDefaultScale: getDefaultScale,\n  getScaleFromProps: getScaleFromProps,\n  getScaleType: getScaleType,\n  getType: getType,\n  getScaleFromName: getScaleFromName\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}