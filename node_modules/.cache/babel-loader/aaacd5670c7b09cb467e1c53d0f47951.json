{"ast":null,"code":"import _identity from \"lodash/identity\";\nimport _defaults from \"lodash/defaults\";\nimport _assign from \"lodash/assign\";\nimport React from \"react\";\nfunction getDatumKey(datum, idx) {\n  return (datum.key || idx).toString();\n}\nfunction getKeyedData(data) {\n  return data.reduce(function (keyedData, datum, idx) {\n    var key = getDatumKey(datum, idx);\n    keyedData[key] = datum;\n    return keyedData;\n  }, {});\n}\nfunction getKeyedDataDifference(a, b) {\n  var hasDifference = false;\n  var difference = Object.keys(a).reduce(function (_difference, key) {\n    if (!(key in b)) {\n      hasDifference = true;\n      _difference[key] = true;\n    }\n    return _difference;\n  }, {});\n  return hasDifference && difference;\n}\n/**\n * Calculate which data-points exist in oldData and not nextData -\n * these are the `exiting` data-points.  Also calculate which\n * data-points exist in nextData and not oldData - these are the\n * `entering` data-points.\n *\n * @param  {Array} oldData   this.props.data Array\n * @param  {Array} nextData  this.props.data Array\n *\n * @return {Object}          Object with `entering` and `exiting` properties.\n *                           entering[datum.key] will be true if the data is\n *                           entering, and similarly for `exiting`.\n */\n\nfunction getNodeTransitions(oldData, nextData) {\n  var oldDataKeyed = oldData && getKeyedData(oldData);\n  var nextDataKeyed = nextData && getKeyedData(nextData);\n  return {\n    entering: oldDataKeyed && getKeyedDataDifference(nextDataKeyed, oldDataKeyed),\n    exiting: nextDataKeyed && getKeyedDataDifference(oldDataKeyed, nextDataKeyed)\n  };\n}\nfunction getChildData(child) {\n  if (child.type && child.type.getData) {\n    return child.type.getData(child.props);\n  }\n  return child.props && child.props.data || false;\n}\n/**\n * If a parent component has animation enabled, calculate the transitions\n * for any data of any child component that supports data transitions\n * Data transitions are defined as any two datasets where data nodes exist\n * in the first set and not the second, in the second and not the first,\n * or both.\n *\n * @param  {Children}  oldChildren   this.props.children from old props\n * @param  {Children}  nextChildren  this.props.children from next props\n *\n * @return {Object}                  Object with the following properties:\n *                                    - nodesWillExit\n *                                    - nodesWillEnter\n *                                    - childrenTransitions\n *                                    - nodesShouldEnter\n */\n\nfunction getInitialTransitionState(oldChildren, nextChildren) {\n  var nodesWillExit = false;\n  var nodesWillEnter = false;\n  var getTransition = function getTransition(oldChild, newChild) {\n    if (!newChild || oldChild.type !== newChild.type) {\n      return {};\n    }\n    var _ref = getNodeTransitions(getChildData(oldChild), getChildData(newChild)) || {},\n      entering = _ref.entering,\n      exiting = _ref.exiting;\n    nodesWillExit = nodesWillExit || !!exiting;\n    nodesWillEnter = nodesWillEnter || !!entering;\n    return {\n      entering: entering || false,\n      exiting: exiting || false\n    };\n  };\n  var getTransitionsFromChildren = function getTransitionsFromChildren(old, next) {\n    return old.map(function (child, idx) {\n      if (child && child.props && child.props.children && next[idx]) {\n        return getTransitionsFromChildren(React.Children.toArray(old[idx].props.children), React.Children.toArray(next[idx].props.children));\n      } // get Transition entering and exiting nodes\n\n      return getTransition(child, next[idx]);\n    });\n  };\n  var childrenTransitions = getTransitionsFromChildren(React.Children.toArray(oldChildren), React.Children.toArray(nextChildren));\n  return {\n    nodesWillExit: nodesWillExit,\n    nodesWillEnter: nodesWillEnter,\n    childrenTransitions: childrenTransitions,\n    // TODO: This may need to be refactored for the following situation.\n    //       The component receives new props, and the data provided\n    //       is a perfect match for the previous data and domain except\n    //       for new nodes. In this case, we wouldn't want a delay before\n    //       the new nodes appear.\n    nodesShouldEnter: false\n  };\n}\nfunction getInitialChildProps(animate, data) {\n  var after = animate.onEnter && animate.onEnter.after ? animate.onEnter.after : _identity;\n  return {\n    data: data.map(function (datum, idx) {\n      return _assign({}, datum, after(datum, idx, data));\n    })\n  };\n} // eslint-disable-next-line max-params\n\nfunction getChildBeforeLoad(animate, child, data, cb) {\n  animate = _assign({}, animate, {\n    onEnd: cb\n  });\n  if (animate && animate.onLoad && !animate.onLoad.duration) {\n    return {\n      animate: animate,\n      data: data\n    };\n  }\n  var before = animate.onLoad && animate.onLoad.before ? animate.onLoad.before : _identity; // If nodes need to exit, transform them with the provided onLoad.before function.\n\n  data = data.map(function (datum, idx) {\n    return _assign({}, datum, before(datum, idx, data));\n  });\n  return {\n    animate: animate,\n    data: data,\n    clipWidth: 0\n  };\n} // eslint-disable-next-line max-params\n\nfunction getChildOnLoad(animate, data, cb) {\n  animate = _assign({}, animate, {\n    onEnd: cb\n  });\n  if (animate && animate.onLoad && !animate.onLoad.duration) {\n    return {\n      animate: animate,\n      data: data\n    };\n  }\n  var after = animate.onLoad && animate.onLoad.after ? animate.onLoad.after : _identity; // If nodes need to exit, transform them with the provided onLoad.after function.\n\n  data = data.map(function (datum, idx) {\n    return _assign({}, datum, after(datum, idx, data));\n  });\n  return {\n    animate: animate,\n    data: data\n  };\n} // eslint-disable-next-line max-params, max-len\n\nfunction getChildPropsOnExit(animate, child, data, exitingNodes, cb) {\n  // Whether or not _this_ child has exiting nodes, we want the exit-\n  // transition for all children to have the same duration, delay, etc.\n  var onExit = animate && animate.onExit;\n  animate = _assign({}, animate, onExit);\n  if (exitingNodes) {\n    // After the exit transition occurs, trigger the animations for\n    // nodes that are neither exiting or entering.\n    animate.onEnd = cb;\n    var before = animate.onExit && animate.onExit.before ? animate.onExit.before : _identity; // If nodes need to exit, transform them with the provided onExit.before function.\n\n    data = data.map(function (datum, idx) {\n      var key = (datum.key || idx).toString();\n      return exitingNodes[key] ? _assign({}, datum, before(datum, idx, data)) : datum;\n    });\n  }\n  return {\n    animate: animate,\n    data: data\n  };\n} // eslint-disable-next-line max-params,max-len\n\nfunction getChildPropsBeforeEnter(animate, child, data, enteringNodes, cb) {\n  if (enteringNodes) {\n    // Perform a normal animation here, except - when it finishes - trigger\n    // the transition for entering nodes.\n    animate = _assign({}, animate, {\n      onEnd: cb\n    });\n    var before = animate.onEnter && animate.onEnter.before ? animate.onEnter.before : _identity; // We want the entering nodes to be included in the transition target\n    // domain.  However, we may not want these nodes to be displayed initially,\n    // so perform the `onEnter.before` transformation on each node.\n\n    data = data.map(function (datum, idx) {\n      var key = (datum.key || idx).toString();\n      return enteringNodes[key] ? _assign({}, datum, before(datum, idx, data)) : datum;\n    });\n  }\n  return {\n    animate: animate,\n    data: data\n  };\n} // eslint-disable-next-line max-params, max-len\n\nfunction getChildPropsOnEnter(animate, data, enteringNodes, cb) {\n  // Whether or not _this_ child has entering nodes, we want the entering-\n  // transition for all children to have the same duration, delay, etc.\n  var onEnter = animate && animate.onEnter;\n  animate = _assign({}, animate, onEnter);\n  if (enteringNodes) {\n    // Old nodes have been transitioned to their new values, and the\n    // domain should encompass the nodes that will now enter. So perform\n    // the `onEnter.after` transformation on each node.\n    animate.onEnd = cb;\n    var after = animate.onEnter && animate.onEnter.after ? animate.onEnter.after : _identity;\n    data = data.map(function (datum, idx) {\n      var key = getDatumKey(datum, idx);\n      return enteringNodes[key] ? _assign({}, datum, after(datum, idx, data)) : datum;\n    });\n  }\n  return {\n    animate: animate,\n    data: data\n  };\n}\n/**\n * getTransitionPropsFactory - putting the Java in JavaScript.  This will return a\n * function that returns prop transformations for a child, given that child's props\n * and its index in the parent's children array.\n *\n * In particular, this will include an `animate` object that is set appropriately\n * so that each child will be synchoronized for each stage of a transition\n * animation.  It will also include a transformed `data` object, where each datum\n * is transformed by `animate.onExit` and `animate.onEnter` `before` and `after`\n * functions.\n *\n * @param  {Object}  props       `this.props` for the parent component.\n * @param  {Object} state        `this.state` for the parent component.\n * @param  {Function} setState    Function that, when called, will `this.setState` on\n *                                 the parent component with the provided object.\n *\n * @return {Function}              Child-prop transformation function.\n */\n\nfunction getTransitionPropsFactory(props, state, setState) {\n  var nodesWillExit = state && state.nodesWillExit;\n  var nodesWillEnter = state && state.nodesWillEnter;\n  var nodesShouldEnter = state && state.nodesShouldEnter;\n  var nodesShouldLoad = state && state.nodesShouldLoad;\n  var nodesDoneLoad = state && state.nodesDoneLoad;\n  var childrenTransitions = state && state.childrenTransitions || [];\n  var transitionDurations = {\n    enter: props.animate && props.animate.onEnter && props.animate.onEnter.duration,\n    exit: props.animate && props.animate.onExit && props.animate.onExit.duration,\n    load: props.animate && props.animate.onLoad && props.animate.onLoad.duration,\n    move: props.animate && props.animate.duration\n  };\n  var onLoad = function onLoad(child, data, animate) {\n    if (nodesShouldLoad) {\n      return getChildOnLoad(animate, data, function () {\n        setState({\n          nodesShouldLoad: false,\n          nodesDoneLoad: true\n        });\n      });\n    }\n    return getChildBeforeLoad(animate, child, data, function () {\n      setState({\n        nodesDoneLoad: true\n      });\n    });\n  }; // eslint-disable-next-line max-params\n\n  var onExit = function onExit(nodes, child, data, animate) {\n    return getChildPropsOnExit(animate, child, data, nodes, function () {\n      setState({\n        nodesWillExit: false\n      });\n    });\n  }; // eslint-disable-next-line max-params\n\n  var onEnter = function onEnter(nodes, child, data, animate) {\n    if (nodesShouldEnter) {\n      return getChildPropsOnEnter(animate, data, nodes, function () {\n        setState({\n          nodesWillEnter: false\n        });\n      });\n    }\n    return getChildPropsBeforeEnter(animate, child, data, nodes, function () {\n      setState({\n        nodesShouldEnter: true\n      });\n    });\n  };\n  var getChildTransitionDuration = function getChildTransitionDuration(child, type) {\n    var animate = child.props.animate;\n    if (!child.type) {\n      return {};\n    }\n    var defaultTransitions = child.props && child.props.polar ? child.type.defaultPolarTransitions || child.type.defaultTransitions : child.type.defaultTransitions;\n    if (defaultTransitions) {\n      var animationDuration = animate[type] && animate[type].duration;\n      return animationDuration !== undefined ? animationDuration : defaultTransitions[type] && defaultTransitions[type].duration;\n    } else {\n      return {};\n    }\n  }; // eslint-disable-next-line max-statements, complexity, max-len\n\n  return function getTransitionProps(child, index) {\n    var data = getChildData(child) || [];\n    var animate = _defaults({}, props.animate, child.props.animate);\n    var defaultTransitions = child.props.polar ? child.type.defaultPolarTransitions || child.type.defaultTransitions : child.type.defaultTransitions;\n    animate.onExit = _defaults({}, animate.onExit, defaultTransitions && defaultTransitions.onExit);\n    animate.onEnter = _defaults({}, animate.onEnter, defaultTransitions && defaultTransitions.onEnter);\n    animate.onLoad = _defaults({}, animate.onLoad, defaultTransitions && defaultTransitions.onLoad);\n    var childTransitions = childrenTransitions[index] || childrenTransitions[0];\n    if (!nodesDoneLoad) {\n      // should do onLoad animation\n      var load = transitionDurations.load !== undefined ? transitionDurations.load : getChildTransitionDuration(child, \"onLoad\");\n      var animation = {\n        duration: load\n      };\n      return onLoad(child, data, _assign({}, animate, animation));\n    } else if (nodesWillExit) {\n      var exitingNodes = childTransitions && childTransitions.exiting;\n      var exit = transitionDurations.exit !== undefined ? transitionDurations.exit : getChildTransitionDuration(child, \"onExit\"); // if nodesWillExit, but this child has no exiting nodes, set a delay instead of a duration\n\n      var _animation = exitingNodes ? {\n        duration: exit\n      } : {\n        delay: exit\n      };\n      return onExit(exitingNodes, child, data, _assign({}, animate, _animation));\n    } else if (nodesWillEnter) {\n      var enteringNodes = childTransitions && childTransitions.entering;\n      var enter = transitionDurations.enter !== undefined ? transitionDurations.enter : getChildTransitionDuration(child, \"onEnter\");\n      var move = transitionDurations.move !== undefined ? transitionDurations.move : child.props.animate && child.props.animate.duration;\n      var _animation2 = {\n        duration: nodesShouldEnter && enteringNodes ? enter : move\n      };\n      return onEnter(enteringNodes, child, data, _assign({}, animate, _animation2));\n    } else if (!state && animate && animate.onExit) {\n      // This is the initial render, and nodes may enter when props change. Because\n      // animation interpolation is determined by old- and next- props, data may need\n      // to be augmented with certain properties.\n      //\n      // For example, it may be desired that exiting nodes go from `opacity: 1` to\n      // `opacity: 0`. Without setting this on a per-datum basis, the interpolation\n      // might go from `opacity: undefined` to `opacity: 0`, which would result in\n      // interpolated `opacity: NaN` values.\n      //\n      return getInitialChildProps(animate, data);\n    }\n    return {\n      animate: animate,\n      data: data\n    };\n  };\n}\nexport default {\n  getInitialTransitionState: getInitialTransitionState,\n  getTransitionPropsFactory: getTransitionPropsFactory\n};","map":{"version":3,"names":["_identity","_defaults","_assign","React","getDatumKey","datum","idx","key","toString","getKeyedData","data","reduce","keyedData","getKeyedDataDifference","a","b","hasDifference","difference","Object","keys","_difference","getNodeTransitions","oldData","nextData","oldDataKeyed","nextDataKeyed","entering","exiting","getChildData","child","type","getData","props","getInitialTransitionState","oldChildren","nextChildren","nodesWillExit","nodesWillEnter","getTransition","oldChild","newChild","_ref","getTransitionsFromChildren","old","next","map","children","Children","toArray","childrenTransitions","nodesShouldEnter","getInitialChildProps","animate","after","onEnter","getChildBeforeLoad","cb","onEnd","onLoad","duration","before","clipWidth","getChildOnLoad","getChildPropsOnExit","exitingNodes","onExit","getChildPropsBeforeEnter","enteringNodes","getChildPropsOnEnter","getTransitionPropsFactory","state","setState","nodesShouldLoad","nodesDoneLoad","transitionDurations","enter","exit","load","move","nodes","getChildTransitionDuration","defaultTransitions","polar","defaultPolarTransitions","animationDuration","undefined","getTransitionProps","index","childTransitions","animation","_animation","delay","_animation2"],"sources":["/root/experiment/nova-explorer/node_modules/victory-core/es/victory-util/transitions.js"],"sourcesContent":["import _identity from \"lodash/identity\";\nimport _defaults from \"lodash/defaults\";\nimport _assign from \"lodash/assign\";\nimport React from \"react\";\n\nfunction getDatumKey(datum, idx) {\n  return (datum.key || idx).toString();\n}\n\nfunction getKeyedData(data) {\n  return data.reduce(function (keyedData, datum, idx) {\n    var key = getDatumKey(datum, idx);\n    keyedData[key] = datum;\n    return keyedData;\n  }, {});\n}\n\nfunction getKeyedDataDifference(a, b) {\n  var hasDifference = false;\n  var difference = Object.keys(a).reduce(function (_difference, key) {\n    if (!(key in b)) {\n      hasDifference = true;\n      _difference[key] = true;\n    }\n\n    return _difference;\n  }, {});\n  return hasDifference && difference;\n}\n/**\n * Calculate which data-points exist in oldData and not nextData -\n * these are the `exiting` data-points.  Also calculate which\n * data-points exist in nextData and not oldData - these are the\n * `entering` data-points.\n *\n * @param  {Array} oldData   this.props.data Array\n * @param  {Array} nextData  this.props.data Array\n *\n * @return {Object}          Object with `entering` and `exiting` properties.\n *                           entering[datum.key] will be true if the data is\n *                           entering, and similarly for `exiting`.\n */\n\n\nfunction getNodeTransitions(oldData, nextData) {\n  var oldDataKeyed = oldData && getKeyedData(oldData);\n  var nextDataKeyed = nextData && getKeyedData(nextData);\n  return {\n    entering: oldDataKeyed && getKeyedDataDifference(nextDataKeyed, oldDataKeyed),\n    exiting: nextDataKeyed && getKeyedDataDifference(oldDataKeyed, nextDataKeyed)\n  };\n}\n\nfunction getChildData(child) {\n  if (child.type && child.type.getData) {\n    return child.type.getData(child.props);\n  }\n\n  return child.props && child.props.data || false;\n}\n/**\n * If a parent component has animation enabled, calculate the transitions\n * for any data of any child component that supports data transitions\n * Data transitions are defined as any two datasets where data nodes exist\n * in the first set and not the second, in the second and not the first,\n * or both.\n *\n * @param  {Children}  oldChildren   this.props.children from old props\n * @param  {Children}  nextChildren  this.props.children from next props\n *\n * @return {Object}                  Object with the following properties:\n *                                    - nodesWillExit\n *                                    - nodesWillEnter\n *                                    - childrenTransitions\n *                                    - nodesShouldEnter\n */\n\n\nfunction getInitialTransitionState(oldChildren, nextChildren) {\n  var nodesWillExit = false;\n  var nodesWillEnter = false;\n\n  var getTransition = function (oldChild, newChild) {\n    if (!newChild || oldChild.type !== newChild.type) {\n      return {};\n    }\n\n    var _ref = getNodeTransitions(getChildData(oldChild), getChildData(newChild)) || {},\n        entering = _ref.entering,\n        exiting = _ref.exiting;\n\n    nodesWillExit = nodesWillExit || !!exiting;\n    nodesWillEnter = nodesWillEnter || !!entering;\n    return {\n      entering: entering || false,\n      exiting: exiting || false\n    };\n  };\n\n  var getTransitionsFromChildren = function (old, next) {\n    return old.map(function (child, idx) {\n      if (child && child.props && child.props.children && next[idx]) {\n        return getTransitionsFromChildren(React.Children.toArray(old[idx].props.children), React.Children.toArray(next[idx].props.children));\n      } // get Transition entering and exiting nodes\n\n\n      return getTransition(child, next[idx]);\n    });\n  };\n\n  var childrenTransitions = getTransitionsFromChildren(React.Children.toArray(oldChildren), React.Children.toArray(nextChildren));\n  return {\n    nodesWillExit: nodesWillExit,\n    nodesWillEnter: nodesWillEnter,\n    childrenTransitions: childrenTransitions,\n    // TODO: This may need to be refactored for the following situation.\n    //       The component receives new props, and the data provided\n    //       is a perfect match for the previous data and domain except\n    //       for new nodes. In this case, we wouldn't want a delay before\n    //       the new nodes appear.\n    nodesShouldEnter: false\n  };\n}\n\nfunction getInitialChildProps(animate, data) {\n  var after = animate.onEnter && animate.onEnter.after ? animate.onEnter.after : _identity;\n  return {\n    data: data.map(function (datum, idx) {\n      return _assign({}, datum, after(datum, idx, data));\n    })\n  };\n} // eslint-disable-next-line max-params\n\n\nfunction getChildBeforeLoad(animate, child, data, cb) {\n  animate = _assign({}, animate, {\n    onEnd: cb\n  });\n\n  if (animate && animate.onLoad && !animate.onLoad.duration) {\n    return {\n      animate: animate,\n      data: data\n    };\n  }\n\n  var before = animate.onLoad && animate.onLoad.before ? animate.onLoad.before : _identity; // If nodes need to exit, transform them with the provided onLoad.before function.\n\n  data = data.map(function (datum, idx) {\n    return _assign({}, datum, before(datum, idx, data));\n  });\n  return {\n    animate: animate,\n    data: data,\n    clipWidth: 0\n  };\n} // eslint-disable-next-line max-params\n\n\nfunction getChildOnLoad(animate, data, cb) {\n  animate = _assign({}, animate, {\n    onEnd: cb\n  });\n\n  if (animate && animate.onLoad && !animate.onLoad.duration) {\n    return {\n      animate: animate,\n      data: data\n    };\n  }\n\n  var after = animate.onLoad && animate.onLoad.after ? animate.onLoad.after : _identity; // If nodes need to exit, transform them with the provided onLoad.after function.\n\n  data = data.map(function (datum, idx) {\n    return _assign({}, datum, after(datum, idx, data));\n  });\n  return {\n    animate: animate,\n    data: data\n  };\n} // eslint-disable-next-line max-params, max-len\n\n\nfunction getChildPropsOnExit(animate, child, data, exitingNodes, cb) {\n  // Whether or not _this_ child has exiting nodes, we want the exit-\n  // transition for all children to have the same duration, delay, etc.\n  var onExit = animate && animate.onExit;\n  animate = _assign({}, animate, onExit);\n\n  if (exitingNodes) {\n    // After the exit transition occurs, trigger the animations for\n    // nodes that are neither exiting or entering.\n    animate.onEnd = cb;\n    var before = animate.onExit && animate.onExit.before ? animate.onExit.before : _identity; // If nodes need to exit, transform them with the provided onExit.before function.\n\n    data = data.map(function (datum, idx) {\n      var key = (datum.key || idx).toString();\n      return exitingNodes[key] ? _assign({}, datum, before(datum, idx, data)) : datum;\n    });\n  }\n\n  return {\n    animate: animate,\n    data: data\n  };\n} // eslint-disable-next-line max-params,max-len\n\n\nfunction getChildPropsBeforeEnter(animate, child, data, enteringNodes, cb) {\n  if (enteringNodes) {\n    // Perform a normal animation here, except - when it finishes - trigger\n    // the transition for entering nodes.\n    animate = _assign({}, animate, {\n      onEnd: cb\n    });\n    var before = animate.onEnter && animate.onEnter.before ? animate.onEnter.before : _identity; // We want the entering nodes to be included in the transition target\n    // domain.  However, we may not want these nodes to be displayed initially,\n    // so perform the `onEnter.before` transformation on each node.\n\n    data = data.map(function (datum, idx) {\n      var key = (datum.key || idx).toString();\n      return enteringNodes[key] ? _assign({}, datum, before(datum, idx, data)) : datum;\n    });\n  }\n\n  return {\n    animate: animate,\n    data: data\n  };\n} // eslint-disable-next-line max-params, max-len\n\n\nfunction getChildPropsOnEnter(animate, data, enteringNodes, cb) {\n  // Whether or not _this_ child has entering nodes, we want the entering-\n  // transition for all children to have the same duration, delay, etc.\n  var onEnter = animate && animate.onEnter;\n  animate = _assign({}, animate, onEnter);\n\n  if (enteringNodes) {\n    // Old nodes have been transitioned to their new values, and the\n    // domain should encompass the nodes that will now enter. So perform\n    // the `onEnter.after` transformation on each node.\n    animate.onEnd = cb;\n    var after = animate.onEnter && animate.onEnter.after ? animate.onEnter.after : _identity;\n    data = data.map(function (datum, idx) {\n      var key = getDatumKey(datum, idx);\n      return enteringNodes[key] ? _assign({}, datum, after(datum, idx, data)) : datum;\n    });\n  }\n\n  return {\n    animate: animate,\n    data: data\n  };\n}\n/**\n * getTransitionPropsFactory - putting the Java in JavaScript.  This will return a\n * function that returns prop transformations for a child, given that child's props\n * and its index in the parent's children array.\n *\n * In particular, this will include an `animate` object that is set appropriately\n * so that each child will be synchoronized for each stage of a transition\n * animation.  It will also include a transformed `data` object, where each datum\n * is transformed by `animate.onExit` and `animate.onEnter` `before` and `after`\n * functions.\n *\n * @param  {Object}  props       `this.props` for the parent component.\n * @param  {Object} state        `this.state` for the parent component.\n * @param  {Function} setState    Function that, when called, will `this.setState` on\n *                                 the parent component with the provided object.\n *\n * @return {Function}              Child-prop transformation function.\n */\n\n\nfunction getTransitionPropsFactory(props, state, setState) {\n  var nodesWillExit = state && state.nodesWillExit;\n  var nodesWillEnter = state && state.nodesWillEnter;\n  var nodesShouldEnter = state && state.nodesShouldEnter;\n  var nodesShouldLoad = state && state.nodesShouldLoad;\n  var nodesDoneLoad = state && state.nodesDoneLoad;\n  var childrenTransitions = state && state.childrenTransitions || [];\n  var transitionDurations = {\n    enter: props.animate && props.animate.onEnter && props.animate.onEnter.duration,\n    exit: props.animate && props.animate.onExit && props.animate.onExit.duration,\n    load: props.animate && props.animate.onLoad && props.animate.onLoad.duration,\n    move: props.animate && props.animate.duration\n  };\n\n  var onLoad = function (child, data, animate) {\n    if (nodesShouldLoad) {\n      return getChildOnLoad(animate, data, function () {\n        setState({\n          nodesShouldLoad: false,\n          nodesDoneLoad: true\n        });\n      });\n    }\n\n    return getChildBeforeLoad(animate, child, data, function () {\n      setState({\n        nodesDoneLoad: true\n      });\n    });\n  }; // eslint-disable-next-line max-params\n\n\n  var onExit = function (nodes, child, data, animate) {\n    return getChildPropsOnExit(animate, child, data, nodes, function () {\n      setState({\n        nodesWillExit: false\n      });\n    });\n  }; // eslint-disable-next-line max-params\n\n\n  var onEnter = function (nodes, child, data, animate) {\n    if (nodesShouldEnter) {\n      return getChildPropsOnEnter(animate, data, nodes, function () {\n        setState({\n          nodesWillEnter: false\n        });\n      });\n    }\n\n    return getChildPropsBeforeEnter(animate, child, data, nodes, function () {\n      setState({\n        nodesShouldEnter: true\n      });\n    });\n  };\n\n  var getChildTransitionDuration = function (child, type) {\n    var animate = child.props.animate;\n\n    if (!child.type) {\n      return {};\n    }\n\n    var defaultTransitions = child.props && child.props.polar ? child.type.defaultPolarTransitions || child.type.defaultTransitions : child.type.defaultTransitions;\n\n    if (defaultTransitions) {\n      var animationDuration = animate[type] && animate[type].duration;\n      return animationDuration !== undefined ? animationDuration : defaultTransitions[type] && defaultTransitions[type].duration;\n    } else {\n      return {};\n    }\n  }; // eslint-disable-next-line max-statements, complexity, max-len\n\n\n  return function getTransitionProps(child, index) {\n    var data = getChildData(child) || [];\n\n    var animate = _defaults({}, props.animate, child.props.animate);\n\n    var defaultTransitions = child.props.polar ? child.type.defaultPolarTransitions || child.type.defaultTransitions : child.type.defaultTransitions;\n    animate.onExit = _defaults({}, animate.onExit, defaultTransitions && defaultTransitions.onExit);\n    animate.onEnter = _defaults({}, animate.onEnter, defaultTransitions && defaultTransitions.onEnter);\n    animate.onLoad = _defaults({}, animate.onLoad, defaultTransitions && defaultTransitions.onLoad);\n    var childTransitions = childrenTransitions[index] || childrenTransitions[0];\n\n    if (!nodesDoneLoad) {\n      // should do onLoad animation\n      var load = transitionDurations.load !== undefined ? transitionDurations.load : getChildTransitionDuration(child, \"onLoad\");\n      var animation = {\n        duration: load\n      };\n      return onLoad(child, data, _assign({}, animate, animation));\n    } else if (nodesWillExit) {\n      var exitingNodes = childTransitions && childTransitions.exiting;\n      var exit = transitionDurations.exit !== undefined ? transitionDurations.exit : getChildTransitionDuration(child, \"onExit\"); // if nodesWillExit, but this child has no exiting nodes, set a delay instead of a duration\n\n      var _animation = exitingNodes ? {\n        duration: exit\n      } : {\n        delay: exit\n      };\n\n      return onExit(exitingNodes, child, data, _assign({}, animate, _animation));\n    } else if (nodesWillEnter) {\n      var enteringNodes = childTransitions && childTransitions.entering;\n      var enter = transitionDurations.enter !== undefined ? transitionDurations.enter : getChildTransitionDuration(child, \"onEnter\");\n      var move = transitionDurations.move !== undefined ? transitionDurations.move : child.props.animate && child.props.animate.duration;\n      var _animation2 = {\n        duration: nodesShouldEnter && enteringNodes ? enter : move\n      };\n      return onEnter(enteringNodes, child, data, _assign({}, animate, _animation2));\n    } else if (!state && animate && animate.onExit) {\n      // This is the initial render, and nodes may enter when props change. Because\n      // animation interpolation is determined by old- and next- props, data may need\n      // to be augmented with certain properties.\n      //\n      // For example, it may be desired that exiting nodes go from `opacity: 1` to\n      // `opacity: 0`. Without setting this on a per-datum basis, the interpolation\n      // might go from `opacity: undefined` to `opacity: 0`, which would result in\n      // interpolated `opacity: NaN` values.\n      //\n      return getInitialChildProps(animate, data);\n    }\n\n    return {\n      animate: animate,\n      data: data\n    };\n  };\n}\n\nexport default {\n  getInitialTransitionState: getInitialTransitionState,\n  getTransitionPropsFactory: getTransitionPropsFactory\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}