{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n  return r;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultOptions = void 0;\nexports.defaultOptions = {\n  skipFirstMutation: false,\n  mutable: false,\n  bfs: false\n};\nvar jsonPathStringify = function jsonPathStringify(s) {\n  return s.map(function (i) {\n    return i === \"\" ? i.toString() : \"/\" + i.toString();\n  }).join(\"\");\n};\nvar isCycle = function isCycle(s, recursiveStack) {\n  var foundInRecursiveStack = recursiveStack.find(function (recSchema) {\n    return recSchema === s;\n  });\n  if (foundInRecursiveStack) {\n    return foundInRecursiveStack;\n  }\n  return false;\n};\n/**\n * Traverse all subschema of a schema, calling the mutator function with each.\n * The mutator is called on leaf nodes first.\n *\n * @param schema the schema to traverse\n * @param mutation the function to pass each node in the subschema tree.\n * @param traverseOptions a set of options for traversal.\n * @param depth For internal use. Tracks the current recursive depth in the tree. This is used to implement\n *              some of the options.\n *\n */\nfunction traverse(schema, mutation, traverseOptions, depth, recursiveStack, pathStack, prePostMap) {\n  if (traverseOptions === void 0) {\n    traverseOptions = exports.defaultOptions;\n  }\n  if (depth === void 0) {\n    depth = 0;\n  }\n  if (recursiveStack === void 0) {\n    recursiveStack = [];\n  }\n  if (pathStack === void 0) {\n    pathStack = [];\n  }\n  if (prePostMap === void 0) {\n    prePostMap = [];\n  }\n  var isRootOfCycle = false;\n  var opts = __assign(__assign({}, exports.defaultOptions), traverseOptions); // would be nice to make an 'entry' func when we get around to optimizations\n  // booleans are a bit messed. Since all other schemas are objects (non-primitive type\n  // which gets a new address in mem) for each new JS refer to one of 2 memory addrs, and\n  // thus adding it to the recursive stack will prevent it from being explored if the\n  // boolean is seen in a further nested schema.\n  if (depth === 0) {\n    pathStack = [\"\"];\n  }\n  if (typeof schema === \"boolean\" || schema instanceof Boolean) {\n    if (opts.skipFirstMutation === true && depth === 0) {\n      return schema;\n    } else {\n      return mutation(schema, false, jsonPathStringify(pathStack));\n    }\n  }\n  var mutableSchema = schema;\n  if (opts.mutable === false) {\n    mutableSchema = __assign({}, schema);\n  }\n  if (opts.bfs === true) {\n    if (opts.skipFirstMutation === false || depth !== 0) {\n      mutableSchema = mutation(mutableSchema, false, jsonPathStringify(pathStack));\n    }\n  }\n  recursiveStack.push(schema);\n  prePostMap.push([schema, mutableSchema]);\n  var rec = function rec(s, path) {\n    var foundCycle = isCycle(s, recursiveStack);\n    if (foundCycle) {\n      if (foundCycle === schema) {\n        isRootOfCycle = true;\n      }\n      // if the cycle is a ref to the root schema && skipFirstMutation is try we need to call mutate.\n      // If we don't, it will never happen.\n      if (opts.skipFirstMutation === true && foundCycle === recursiveStack[0]) {\n        return mutation(s, true, jsonPathStringify(path));\n      }\n      var _a = prePostMap.find(function (_a) {\n          var orig = _a[0];\n          return foundCycle === orig;\n        }),\n        cycledMutableSchema = _a[1];\n      return cycledMutableSchema;\n    }\n    return traverse(s, mutation, traverseOptions, depth + 1, recursiveStack, path, prePostMap);\n  };\n  if (schema.anyOf) {\n    mutableSchema.anyOf = schema.anyOf.map(function (x, i) {\n      var result = rec(x, __spreadArrays(pathStack, [\"anyOf\", i.toString()]));\n      return result;\n    });\n  } else if (schema.allOf) {\n    mutableSchema.allOf = schema.allOf.map(function (x, i) {\n      var result = rec(x, __spreadArrays(pathStack, [\"allOf\", i.toString()]));\n      return result;\n    });\n  } else if (schema.oneOf) {\n    mutableSchema.oneOf = schema.oneOf.map(function (x, i) {\n      var result = rec(x, __spreadArrays(pathStack, [\"oneOf\", i.toString()]));\n      return result;\n    });\n  } else {\n    var itemsIsSingleSchema = false;\n    if (schema.items) {\n      if (schema.items instanceof Array) {\n        mutableSchema.items = schema.items.map(function (x, i) {\n          var result = rec(x, __spreadArrays(pathStack, [\"items\", i.toString()]));\n          return result;\n        });\n      } else {\n        var foundCycle_1 = isCycle(schema.items, recursiveStack);\n        if (foundCycle_1) {\n          if (foundCycle_1 === schema) {\n            isRootOfCycle = true;\n          }\n          if (opts.skipFirstMutation === true && foundCycle_1 === recursiveStack[0]) {\n            mutableSchema.items = mutation(schema.items, true, jsonPathStringify(pathStack));\n          } else {\n            var _a = prePostMap.find(function (_a) {\n                var orig = _a[0];\n                return foundCycle_1 === orig;\n              }),\n              cycledMutableSchema = _a[1];\n            mutableSchema.items = cycledMutableSchema;\n          }\n        } else {\n          itemsIsSingleSchema = true;\n          mutableSchema.items = traverse(schema.items, mutation, traverseOptions, depth + 1, recursiveStack, pathStack, prePostMap);\n        }\n      }\n    }\n    if (schema.additionalItems !== undefined && !!schema.additionalItems === true && !itemsIsSingleSchema) {\n      mutableSchema.additionalItems = rec(schema.additionalItems, __spreadArrays(pathStack, [\"additionalItems\"]));\n    }\n    if (schema.properties !== undefined) {\n      var sProps_1 = schema.properties;\n      var mutableProps_1 = {};\n      Object.keys(schema.properties).forEach(function (schemaPropKey) {\n        mutableProps_1[schemaPropKey] = rec(sProps_1[schemaPropKey], __spreadArrays(pathStack, [\"properties\", schemaPropKey.toString()]));\n      });\n      mutableSchema.properties = mutableProps_1;\n    }\n    if (schema.patternProperties !== undefined) {\n      var sProps_2 = schema.patternProperties;\n      var mutableProps_2 = {};\n      Object.keys(schema.patternProperties).forEach(function (regex) {\n        mutableProps_2[regex] = rec(sProps_2[regex], __spreadArrays(pathStack, [\"patternProperties\", regex.toString()]));\n      });\n      mutableSchema.patternProperties = mutableProps_2;\n    }\n    if (schema.additionalProperties !== undefined && !!schema.additionalProperties === true) {\n      mutableSchema.additionalProperties = rec(schema.additionalProperties, __spreadArrays(pathStack, [\"additionalProperties\"]));\n    }\n  }\n  if (opts.skipFirstMutation === true && depth === 0) {\n    return mutableSchema;\n  }\n  if (opts.bfs === true) {\n    return mutableSchema;\n  } else {\n    return mutation(mutableSchema, isRootOfCycle, jsonPathStringify(pathStack));\n  }\n}\nexports.default = traverse;","map":{"version":3,"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__spreadArrays","il","r","Array","k","a","j","jl","defineProperty","exports","value","defaultOptions","skipFirstMutation","mutable","bfs","jsonPathStringify","map","toString","join","isCycle","recursiveStack","foundInRecursiveStack","find","recSchema","traverse","schema","mutation","traverseOptions","depth","pathStack","prePostMap","isRootOfCycle","opts","Boolean","mutableSchema","push","rec","path","foundCycle","_a","orig","cycledMutableSchema","anyOf","x","result","allOf","oneOf","itemsIsSingleSchema","items","foundCycle_1","additionalItems","undefined","properties","sProps_1","mutableProps_1","keys","forEach","schemaPropKey","patternProperties","sProps_2","mutableProps_2","regex","additionalProperties","default"],"sources":["/root/experiment/nova-explorer/node_modules/@json-schema-tools/traverse/build/index.js"],"sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultOptions = void 0;\nexports.defaultOptions = {\n    skipFirstMutation: false,\n    mutable: false,\n    bfs: false,\n};\nvar jsonPathStringify = function (s) {\n    return s.map(function (i) { return i === \"\" ? i.toString() : (\"/\" + i.toString()); }).join(\"\");\n};\nvar isCycle = function (s, recursiveStack) {\n    var foundInRecursiveStack = recursiveStack.find(function (recSchema) { return recSchema === s; });\n    if (foundInRecursiveStack) {\n        return foundInRecursiveStack;\n    }\n    return false;\n};\n/**\n * Traverse all subschema of a schema, calling the mutator function with each.\n * The mutator is called on leaf nodes first.\n *\n * @param schema the schema to traverse\n * @param mutation the function to pass each node in the subschema tree.\n * @param traverseOptions a set of options for traversal.\n * @param depth For internal use. Tracks the current recursive depth in the tree. This is used to implement\n *              some of the options.\n *\n */\nfunction traverse(schema, mutation, traverseOptions, depth, recursiveStack, pathStack, prePostMap) {\n    if (traverseOptions === void 0) { traverseOptions = exports.defaultOptions; }\n    if (depth === void 0) { depth = 0; }\n    if (recursiveStack === void 0) { recursiveStack = []; }\n    if (pathStack === void 0) { pathStack = []; }\n    if (prePostMap === void 0) { prePostMap = []; }\n    var isRootOfCycle = false;\n    var opts = __assign(__assign({}, exports.defaultOptions), traverseOptions); // would be nice to make an 'entry' func when we get around to optimizations\n    // booleans are a bit messed. Since all other schemas are objects (non-primitive type\n    // which gets a new address in mem) for each new JS refer to one of 2 memory addrs, and\n    // thus adding it to the recursive stack will prevent it from being explored if the\n    // boolean is seen in a further nested schema.\n    if (depth === 0) {\n        pathStack = [\"\"];\n    }\n    if (typeof schema === \"boolean\" || schema instanceof Boolean) {\n        if (opts.skipFirstMutation === true && depth === 0) {\n            return schema;\n        }\n        else {\n            return mutation(schema, false, jsonPathStringify(pathStack));\n        }\n    }\n    var mutableSchema = schema;\n    if (opts.mutable === false) {\n        mutableSchema = __assign({}, schema);\n    }\n    if (opts.bfs === true) {\n        if (opts.skipFirstMutation === false || depth !== 0) {\n            mutableSchema = mutation(mutableSchema, false, jsonPathStringify(pathStack));\n        }\n    }\n    recursiveStack.push(schema);\n    prePostMap.push([schema, mutableSchema]);\n    var rec = function (s, path) {\n        var foundCycle = isCycle(s, recursiveStack);\n        if (foundCycle) {\n            if (foundCycle === schema) {\n                isRootOfCycle = true;\n            }\n            // if the cycle is a ref to the root schema && skipFirstMutation is try we need to call mutate.\n            // If we don't, it will never happen.\n            if (opts.skipFirstMutation === true && foundCycle === recursiveStack[0]) {\n                return mutation(s, true, jsonPathStringify(path));\n            }\n            var _a = prePostMap.find(function (_a) {\n                var orig = _a[0];\n                return foundCycle === orig;\n            }), cycledMutableSchema = _a[1];\n            return cycledMutableSchema;\n        }\n        return traverse(s, mutation, traverseOptions, depth + 1, recursiveStack, path, prePostMap);\n    };\n    if (schema.anyOf) {\n        mutableSchema.anyOf = schema.anyOf.map(function (x, i) {\n            var result = rec(x, __spreadArrays(pathStack, [\"anyOf\", i.toString()]));\n            return result;\n        });\n    }\n    else if (schema.allOf) {\n        mutableSchema.allOf = schema.allOf.map(function (x, i) {\n            var result = rec(x, __spreadArrays(pathStack, [\"allOf\", i.toString()]));\n            return result;\n        });\n    }\n    else if (schema.oneOf) {\n        mutableSchema.oneOf = schema.oneOf.map(function (x, i) {\n            var result = rec(x, __spreadArrays(pathStack, [\"oneOf\", i.toString()]));\n            return result;\n        });\n    }\n    else {\n        var itemsIsSingleSchema = false;\n        if (schema.items) {\n            if (schema.items instanceof Array) {\n                mutableSchema.items = schema.items.map(function (x, i) {\n                    var result = rec(x, __spreadArrays(pathStack, [\"items\", i.toString()]));\n                    return result;\n                });\n            }\n            else {\n                var foundCycle_1 = isCycle(schema.items, recursiveStack);\n                if (foundCycle_1) {\n                    if (foundCycle_1 === schema) {\n                        isRootOfCycle = true;\n                    }\n                    if (opts.skipFirstMutation === true && foundCycle_1 === recursiveStack[0]) {\n                        mutableSchema.items = mutation(schema.items, true, jsonPathStringify(pathStack));\n                    }\n                    else {\n                        var _a = prePostMap.find(function (_a) {\n                            var orig = _a[0];\n                            return foundCycle_1 === orig;\n                        }), cycledMutableSchema = _a[1];\n                        mutableSchema.items = cycledMutableSchema;\n                    }\n                }\n                else {\n                    itemsIsSingleSchema = true;\n                    mutableSchema.items = traverse(schema.items, mutation, traverseOptions, depth + 1, recursiveStack, pathStack, prePostMap);\n                }\n            }\n        }\n        if (schema.additionalItems !== undefined && !!schema.additionalItems === true && !itemsIsSingleSchema) {\n            mutableSchema.additionalItems = rec(schema.additionalItems, __spreadArrays(pathStack, [\"additionalItems\"]));\n        }\n        if (schema.properties !== undefined) {\n            var sProps_1 = schema.properties;\n            var mutableProps_1 = {};\n            Object.keys(schema.properties).forEach(function (schemaPropKey) {\n                mutableProps_1[schemaPropKey] = rec(sProps_1[schemaPropKey], __spreadArrays(pathStack, [\"properties\", schemaPropKey.toString()]));\n            });\n            mutableSchema.properties = mutableProps_1;\n        }\n        if (schema.patternProperties !== undefined) {\n            var sProps_2 = schema.patternProperties;\n            var mutableProps_2 = {};\n            Object.keys(schema.patternProperties).forEach(function (regex) {\n                mutableProps_2[regex] = rec(sProps_2[regex], __spreadArrays(pathStack, [\"patternProperties\", regex.toString()]));\n            });\n            mutableSchema.patternProperties = mutableProps_2;\n        }\n        if (schema.additionalProperties !== undefined && !!schema.additionalProperties === true) {\n            mutableSchema.additionalProperties = rec(schema.additionalProperties, __spreadArrays(pathStack, [\"additionalProperties\"]));\n        }\n    }\n    if (opts.skipFirstMutation === true && depth === 0) {\n        return mutableSchema;\n    }\n    if (opts.bfs === true) {\n        return mutableSchema;\n    }\n    else {\n        return mutation(mutableSchema, isRootOfCycle, jsonPathStringify(pathStack));\n    }\n}\nexports.default = traverse;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}