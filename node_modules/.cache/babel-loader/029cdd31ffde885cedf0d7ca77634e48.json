{"ast":null,"code":"import * as React from 'react';\nimport { parse as parseQueryString, parseUrl as parseQueryURL, stringify, StringParam } from 'serialize-query-params';\nimport { QueryParamContext } from './QueryParamProvider';\nimport { updateUrlQuery } from './updateUrlQuery';\n/**\n * Given a query param name and query parameter configuration ({ encode, decode })\n * return the decoded value and a setter for updating it.\n *\n * The setter takes two arguments (newValue, updateType) where updateType\n * is one of 'replace' | 'replaceIn' | 'push' | 'pushIn', defaulting to\n * 'replaceIn'.\n *\n * You may optionally pass in a rawQuery object, otherwise the query is derived\n * from the location available in the QueryParamContext.\n *\n * D = decoded type\n * D2 = return value from decode (typically same as D)\n */\nexport var useQueryParam = function useQueryParam(name, paramConfig, rawQuery) {\n  var _a;\n  if (paramConfig === void 0) {\n    paramConfig = StringParam;\n  }\n  var _b = React.useContext(QueryParamContext),\n    history = _b.history,\n    location = _b.location;\n  // ref with current version history object (see #46)\n  var refHistory = React.useRef(history);\n  React.useEffect(function () {\n    refHistory.current = history;\n  }, [history]);\n  // ref with current version location object (see #46)\n  var refLocation = React.useRef(location);\n  React.useEffect(function () {\n    refLocation.current = location;\n  }, [location]);\n  // read in the raw query\n  if (!rawQuery) {\n    var locationIsObject_1 = typeof location === 'object';\n    var windowIsDefined_1 = typeof window !== 'undefined';\n    rawQuery = React.useMemo(function () {\n      var pathname = {};\n      // handle checking SSR (#13)\n      if (locationIsObject_1) {\n        // in browser\n        if (windowIsDefined_1) {\n          pathname = parseQueryString(location.search);\n        } else {\n          // not in browser\n          var url = location.pathname;\n          if (location.search) {\n            url += location.search;\n          }\n          pathname = parseQueryURL(url).query;\n        }\n      }\n      return pathname || {};\n    }, [location.search, location.pathname, locationIsObject_1, windowIsDefined_1]);\n  }\n  // read in the encoded string value\n  var encodedValue = rawQuery[name];\n  // note that we use the stringified encoded value since the encoded\n  // value may be an array that is recreated if a different query param\n  // changes. It is sufficient to use this instead of encodedValue in\n  // the useMemo dependency array since it will change any time the actual\n  // meaningful value of encodedValue changes.\n  var arraySafeEncodedValue = encodedValue instanceof Array ? stringify((_a = {}, _a[name] = encodedValue, _a)) : encodedValue;\n  // decode if the encoded value has changed, otherwise\n  // re-use memoized value\n  var decodedValue = React.useMemo(function () {\n    if (encodedValue == null) {\n      return undefined;\n    }\n    return paramConfig.decode(encodedValue);\n  }, [arraySafeEncodedValue, paramConfig]); // eslint-disable-line react-hooks/exhaustive-deps\n  // create the setter, memoizing via useCallback\n  var setValue = React.useCallback(function (newValue, updateType) {\n    var _a;\n    var newEncodedValue = paramConfig.encode(newValue);\n    updateUrlQuery((_a = {}, _a[name] = newEncodedValue, _a), refHistory.current.location || refLocation.current,\n    // see #46 for why we use a ref here\n    refHistory.current, updateType);\n  }, [paramConfig, name]);\n  return [decodedValue, setValue];\n};","map":{"version":3,"names":["React","parse","parseQueryString","parseUrl","parseQueryURL","stringify","StringParam","QueryParamContext","updateUrlQuery","useQueryParam","name","paramConfig","rawQuery","_a","_b","useContext","history","location","refHistory","useRef","useEffect","current","refLocation","locationIsObject_1","windowIsDefined_1","window","useMemo","pathname","search","url","query","encodedValue","arraySafeEncodedValue","Array","decodedValue","undefined","decode","setValue","useCallback","newValue","updateType","newEncodedValue","encode"],"sources":["/root/experiment/nova-explorer/node_modules/use-query-params/esm/useQueryParam.js"],"sourcesContent":["import * as React from 'react';\nimport { parse as parseQueryString, parseUrl as parseQueryURL, stringify, StringParam, } from 'serialize-query-params';\nimport { QueryParamContext } from './QueryParamProvider';\nimport { updateUrlQuery } from './updateUrlQuery';\n/**\n * Given a query param name and query parameter configuration ({ encode, decode })\n * return the decoded value and a setter for updating it.\n *\n * The setter takes two arguments (newValue, updateType) where updateType\n * is one of 'replace' | 'replaceIn' | 'push' | 'pushIn', defaulting to\n * 'replaceIn'.\n *\n * You may optionally pass in a rawQuery object, otherwise the query is derived\n * from the location available in the QueryParamContext.\n *\n * D = decoded type\n * D2 = return value from decode (typically same as D)\n */\nexport var useQueryParam = function (name, paramConfig, rawQuery) {\n    var _a;\n    if (paramConfig === void 0) { paramConfig = StringParam; }\n    var _b = React.useContext(QueryParamContext), history = _b.history, location = _b.location;\n    // ref with current version history object (see #46)\n    var refHistory = React.useRef(history);\n    React.useEffect(function () {\n        refHistory.current = history;\n    }, [history]);\n    // ref with current version location object (see #46)\n    var refLocation = React.useRef(location);\n    React.useEffect(function () {\n        refLocation.current = location;\n    }, [location]);\n    // read in the raw query\n    if (!rawQuery) {\n        var locationIsObject_1 = typeof location === 'object';\n        var windowIsDefined_1 = typeof window !== 'undefined';\n        rawQuery = React.useMemo(function () {\n            var pathname = {};\n            // handle checking SSR (#13)\n            if (locationIsObject_1) {\n                // in browser\n                if (windowIsDefined_1) {\n                    pathname = parseQueryString(location.search);\n                }\n                else {\n                    // not in browser\n                    var url = location.pathname;\n                    if (location.search) {\n                        url += location.search;\n                    }\n                    pathname = parseQueryURL(url).query;\n                }\n            }\n            return pathname || {};\n        }, [location.search, location.pathname, locationIsObject_1, windowIsDefined_1]);\n    }\n    // read in the encoded string value\n    var encodedValue = rawQuery[name];\n    // note that we use the stringified encoded value since the encoded\n    // value may be an array that is recreated if a different query param\n    // changes. It is sufficient to use this instead of encodedValue in\n    // the useMemo dependency array since it will change any time the actual\n    // meaningful value of encodedValue changes.\n    var arraySafeEncodedValue = encodedValue instanceof Array\n        ? stringify((_a = {}, _a[name] = encodedValue, _a))\n        : encodedValue;\n    // decode if the encoded value has changed, otherwise\n    // re-use memoized value\n    var decodedValue = React.useMemo(function () {\n        if (encodedValue == null) {\n            return undefined;\n        }\n        return paramConfig.decode(encodedValue);\n    }, [arraySafeEncodedValue, paramConfig]); // eslint-disable-line react-hooks/exhaustive-deps\n    // create the setter, memoizing via useCallback\n    var setValue = React.useCallback(function (newValue, updateType) {\n        var _a;\n        var newEncodedValue = paramConfig.encode(newValue);\n        updateUrlQuery((_a = {}, _a[name] = newEncodedValue, _a), refHistory.current.location || refLocation.current, // see #46 for why we use a ref here\n        refHistory.current, updateType);\n    }, [paramConfig, name]);\n    return [decodedValue, setValue];\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}