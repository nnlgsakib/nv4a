{"ast":null,"code":"import _includes from \"lodash/includes\";\nimport _isFunction from \"lodash/isFunction\";\nimport _sortedUniq from \"lodash/sortedUniq\";\nimport _isPlainObject from \"lodash/isPlainObject\";\nimport _flatten from \"lodash/flatten\";\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  }\n}\n\n/* eslint-disable func-style */\n\n/* eslint-disable no-use-before-define */\nimport React from \"react\";\nimport Data from \"./data\";\nimport Scale from \"./scale\";\nimport Helpers from \"./helpers\";\nimport Collection from \"./collection\"; // Private Methods\n\nfunction cleanDomain(domain, props, axis) {\n  var scaleType = Scale.getScaleType(props, axis);\n  if (scaleType !== \"log\") {\n    return domain;\n  }\n  var rules = function rules(dom) {\n    var almostZero = dom[0] < 0 || dom[1] < 0 ? -1 / Number.MAX_SAFE_INTEGER : 1 / Number.MAX_SAFE_INTEGER;\n    var domainOne = dom[0] === 0 ? almostZero : dom[0];\n    var domainTwo = dom[1] === 0 ? almostZero : dom[1];\n    return [domainOne, domainTwo];\n  };\n  return rules(domain);\n}\nfunction getDomainPadding(props, axis) {\n  var formatPadding = function formatPadding(padding) {\n    return Array.isArray(padding) ? {\n      left: padding[0],\n      right: padding[1]\n    } : {\n      left: padding,\n      right: padding\n    };\n  };\n  return _isPlainObject(props.domainPadding) ? formatPadding(props.domainPadding[axis]) : formatPadding(props.domainPadding);\n}\nfunction getFlatData(dataset, axis) {\n  return _flatten(dataset).map(function (datum) {\n    return datum[\"_\".concat(axis)] && datum[\"_\".concat(axis)][1] !== undefined ? datum[\"_\".concat(axis)][1] : datum[\"_\".concat(axis)];\n  });\n}\nfunction getExtremeFromData(dataset, axis) {\n  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"min\";\n  var getExtreme = function getExtreme(arr) {\n    return type === \"max\" ? Math.max.apply(Math, _toConsumableArray(arr)) : Math.min.apply(Math, _toConsumableArray(arr));\n  };\n  var initialValue = type === \"max\" ? -Infinity : Infinity;\n  var containsDate = false;\n  var result = _flatten(dataset).reduce(function (memo, datum) {\n    var current0 = datum[\"_\".concat(axis, \"0\")] !== undefined ? datum[\"_\".concat(axis, \"0\")] : datum[\"_\".concat(axis)];\n    var current1 = datum[\"_\".concat(axis, \"1\")] !== undefined ? datum[\"_\".concat(axis, \"1\")] : datum[\"_\".concat(axis)];\n    var current = getExtreme([current0, current1]);\n    containsDate = containsDate || current0 instanceof Date || current1 instanceof Date;\n    return getExtreme([memo, current]);\n  }, initialValue);\n  return containsDate ? new Date(result) : result;\n} //eslint-disable-next-line max-statements\n\nfunction padDomain(domain, props, axis) {\n  if (!props.domainPadding) {\n    return domain;\n  }\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n  var padding = getDomainPadding(props, axis);\n  if (!padding.left && !padding.right) {\n    return domain;\n  }\n  var min = Collection.getMinValue(domain);\n  var max = Collection.getMaxValue(domain);\n  var currentAxis = Helpers.getCurrentAxis(axis, props.horizontal);\n  var range = Helpers.getRange(props, currentAxis);\n  var rangeExtent = Math.abs(range[0] - range[1]); // Naive initial padding calculation\n\n  var initialPadding = {\n    left: Math.abs(max - min) * padding.left / rangeExtent,\n    right: Math.abs(max - min) * padding.right / rangeExtent\n  };\n  var singleQuadrantDomainPadding = _isPlainObject(props.singleQuadrantDomainPadding) ? props.singleQuadrantDomainPadding[axis] : props.singleQuadrantDomainPadding;\n  var adjust = function adjust(val, type) {\n    if (singleQuadrantDomainPadding === false) {\n      return val;\n    }\n    var coerce = type === \"min\" && min >= 0 && val <= 0 || type === \"max\" && max <= 0 && val >= 0;\n    return coerce ? 0 : val;\n  }; // Adjust the domain by the initial padding\n\n  var adjustedDomain = {\n    min: adjust(min.valueOf() - initialPadding.left, \"min\"),\n    max: adjust(max.valueOf() + initialPadding.right, \"max\")\n  }; // re-calculate padding, taking the adjusted domain into account\n\n  var finalPadding = {\n    left: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.left / rangeExtent,\n    right: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.right / rangeExtent\n  }; // Adjust the domain by the final padding\n\n  var paddedDomain = {\n    min: adjust(min.valueOf() - finalPadding.left, \"min\"),\n    max: adjust(max.valueOf() + finalPadding.right, \"max\")\n  }; // default to minDomain / maxDomain if they exist\n\n  var finalDomain = {\n    min: minDomain !== undefined ? minDomain : paddedDomain.min,\n    max: maxDomain !== undefined ? maxDomain : paddedDomain.max\n  };\n  return min instanceof Date || max instanceof Date ? getDomainFromMinMax(new Date(finalDomain.min), new Date(finalDomain.max)) : getDomainFromMinMax(finalDomain.min, finalDomain.max);\n} // Public Methods\n\n/**\n * Returns a getDomain function\n * @param {Function} getDomainFromDataFunction: a function that takes props and axis and\n * returns a domain based on data\n * @param {Function} formatDomainFunction: a function that takes domain, props, and axis and\n * returns a formatted domain\n * @returns {Function} a function that takes props and axis and returns a formatted domain\n */\n\nfunction createDomainFunction(getDomainFromDataFunction, formatDomainFunction) {\n  getDomainFromDataFunction = _isFunction(getDomainFromDataFunction) ? getDomainFromDataFunction : getDomainFromData;\n  formatDomainFunction = _isFunction(formatDomainFunction) ? formatDomainFunction : formatDomain;\n  return function (props, axis) {\n    var propsDomain = getDomainFromProps(props, axis);\n    if (propsDomain) {\n      return formatDomainFunction(propsDomain, props, axis);\n    }\n    var categories = Data.getCategories(props, axis);\n    var domain = categories ? getDomainFromCategories(props, axis, categories) : getDomainFromDataFunction(props, axis);\n    return domain ? formatDomainFunction(domain, props, axis) : undefined;\n  };\n}\n/**\n * Returns a formatted domain.\n * @param {Array} domain: a domain in the form of a two element array\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} a domain in the form of a two element array\n */\n\nfunction formatDomain(domain, props, axis) {\n  return cleanDomain(padDomain(domain, props, axis), props, axis);\n}\n/**\n * Returns a domain for a given axis based on props, category, or data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} the domain for the given axis\n */\n\nfunction getDomain(props, axis) {\n  return createDomainFunction()(props, axis);\n}\n/**\n * Returns a domain based on categories if they exist\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @param {Array} categories: an array of categories corresponding to a given axis\n * @returns {Array|undefined} returns a domain from categories or undefined\n */\n\nfunction getDomainFromCategories(props, axis, categories) {\n  categories = categories || Data.getCategories(props, axis);\n  var polar = props.polar,\n    _props$startAngle = props.startAngle,\n    startAngle = _props$startAngle === void 0 ? 0 : _props$startAngle,\n    _props$endAngle = props.endAngle,\n    endAngle = _props$endAngle === void 0 ? 360 : _props$endAngle;\n  if (!categories) {\n    return undefined;\n  }\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n  var stringArray = Collection.containsStrings(categories) ? Data.getStringsFromCategories(props, axis) : [];\n  var stringMap = stringArray.length === 0 ? null : stringArray.reduce(function (memo, string, index) {\n    memo[string] = index + 1;\n    return memo;\n  }, {});\n  var categoryValues = stringMap ? categories.map(function (value) {\n    return stringMap[value];\n  }) : categories;\n  var min = minDomain !== undefined ? minDomain : Collection.getMinValue(categoryValues);\n  var max = maxDomain !== undefined ? maxDomain : Collection.getMaxValue(categoryValues);\n  var categoryDomain = getDomainFromMinMax(min, max);\n  return polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? getSymmetricDomain(categoryDomain, categoryValues) : categoryDomain;\n}\n/**\n * Returns a domain from a dataset for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @param {Array} dataset: an array of data\n * @returns {Array} the domain based on data\n */\n\nfunction getDomainFromData(props, axis, dataset) {\n  dataset = dataset || Data.getData(props);\n  var polar = props.polar,\n    _props$startAngle2 = props.startAngle,\n    startAngle = _props$startAngle2 === void 0 ? 0 : _props$startAngle2,\n    _props$endAngle2 = props.endAngle,\n    endAngle = _props$endAngle2 === void 0 ? 360 : _props$endAngle2;\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n  if (dataset.length < 1) {\n    return minDomain !== undefined && maxDomain !== undefined ? getDomainFromMinMax(minDomain, maxDomain) : undefined;\n  }\n  var min = minDomain !== undefined ? minDomain : getExtremeFromData(dataset, axis, \"min\");\n  var max = maxDomain !== undefined ? maxDomain : getExtremeFromData(dataset, axis, \"max\");\n  var domain = getDomainFromMinMax(min, max);\n  return polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? getSymmetricDomain(domain, getFlatData(dataset, axis)) : domain;\n}\n/**\n * Returns a domain in the form of a two element array given a min and max value.\n * @param {Number|Date} min: the props object\n * @param {Number|Date} max: the current axis\n * @returns {Array} the minDomain based on props\n */\n\nfunction getDomainFromMinMax(min, max) {\n  var getSinglePointDomain = function getSinglePointDomain(val) {\n    // d3-scale does not properly resolve very small differences.\n    // eslint-disable-next-line no-magic-numbers\n    var verySmallNumber = val === 0 ? 2 * Math.pow(10, -10) : Math.pow(10, -10);\n    var verySmallDate = 1;\n    var minVal = val instanceof Date ? new Date(+val - verySmallDate) : +val - verySmallNumber;\n    var maxVal = val instanceof Date ? new Date(+val + verySmallDate) : +val + verySmallNumber;\n    return val === 0 ? [0, maxVal] : [minVal, maxVal];\n  };\n  return +min === +max ? getSinglePointDomain(max) : [min, max];\n}\n/**\n * Returns a the domain for a given axis if domain is given in props\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array|undefined} the domain based on props\n */\n\nfunction getDomainFromProps(props, axis) {\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n  if (_isPlainObject(props.domain) && props.domain[axis]) {\n    return props.domain[axis];\n  } else if (Array.isArray(props.domain)) {\n    return props.domain;\n  } else if (minDomain !== undefined && maxDomain !== undefined) {\n    return getDomainFromMinMax(minDomain, maxDomain);\n  }\n  return undefined;\n}\n/**\n * Returns a domain for a given axis. This method forces the domain to include\n * zero unless the domain is explicitly specified in props.\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} the domain for the given axis\n */\n\nfunction getDomainWithZero(props, axis) {\n  var propsDomain = getDomainFromProps(props, axis);\n  if (propsDomain) {\n    return propsDomain;\n  }\n  var dataset = Data.getData(props);\n  var y0Min = dataset.reduce(function (min, datum) {\n    return datum._y0 < min ? datum._y0 : min;\n  }, Infinity);\n  var ensureZero = function ensureZero(domain) {\n    if (axis === \"x\") {\n      return domain;\n    }\n    var defaultMin = y0Min !== Infinity ? y0Min : 0;\n    var maxDomainProp = getMaxFromProps(props, axis);\n    var minDomainProp = getMinFromProps(props, axis);\n    var max = maxDomainProp !== undefined ? maxDomainProp : Collection.getMaxValue(domain, defaultMin);\n    var min = minDomainProp !== undefined ? minDomainProp : Collection.getMinValue(domain, defaultMin);\n    return getDomainFromMinMax(min, max);\n  };\n  var getDomainFunction = function getDomainFunction() {\n    return getDomainFromData(props, axis, dataset);\n  };\n  var formatDomainFunction = function formatDomainFunction(domain) {\n    return formatDomain(ensureZero(domain), props, axis);\n  };\n  return createDomainFunction(getDomainFunction, formatDomainFunction)(props, axis);\n}\n/**\n * Returns the maxDomain from props if it exists\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Number|undefined} the maxDomain based on props\n */\n\nfunction getMaxFromProps(props, axis) {\n  if (_isPlainObject(props.maxDomain) && props.maxDomain[axis] !== undefined) {\n    return props.maxDomain[axis];\n  }\n  return typeof props.maxDomain === \"number\" ? props.maxDomain : undefined;\n}\n/**\n * Returns the minDomain from props if it exists\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Number|undefined} the minDomain based on props\n */\n\nfunction getMinFromProps(props, axis) {\n  if (_isPlainObject(props.minDomain) && props.minDomain[axis] !== undefined) {\n    return props.minDomain[axis];\n  }\n  return typeof props.minDomain === \"number\" ? props.minDomain : undefined;\n}\n/**\n * Returns a symmetrically padded domain for polar charts\n * @param {Array} domain: the original domain\n * @param {Array} values: a flat array of values corresponding to either tickValues, or data values\n * for a given dimension i.e. only x values.\n * @returns {Array} the symmetric domain\n */\n\nfunction getSymmetricDomain(domain, values) {\n  var processedData = _sortedUniq(values.sort(function (a, b) {\n    return a - b;\n  }));\n  var step = processedData[1] - processedData[0];\n  return [domain[0], domain[1] + step];\n}\n/**\n * Checks whether a given component can be used to calculate domain\n * @param {Component} component: a React component instance\n * @returns {Boolean} Returns true if the given component has a role included in the whitelist\n */\n\nfunction isDomainComponent(component) {\n  var getRole = function getRole(child) {\n    return child && child.type ? child.type.role : \"\";\n  };\n  var role = getRole(component);\n  if (role === \"portal\") {\n    var children = React.Children.toArray(component.props.children);\n    role = children.length ? getRole(children[0]) : \"\";\n  }\n  var whitelist = [\"area\", \"axis\", \"bar\", \"boxplot\", \"candlestick\", \"errorbar\", \"group\", \"line\", \"pie\", \"scatter\", \"stack\", \"voronoi\"];\n  return _includes(whitelist, role);\n}\nexport default {\n  createDomainFunction: createDomainFunction,\n  formatDomain: formatDomain,\n  getDomain: getDomain,\n  getDomainFromCategories: getDomainFromCategories,\n  getDomainFromData: getDomainFromData,\n  getDomainFromMinMax: getDomainFromMinMax,\n  getDomainFromProps: getDomainFromProps,\n  getDomainWithZero: getDomainWithZero,\n  getMaxFromProps: getMaxFromProps,\n  getMinFromProps: getMinFromProps,\n  getSymmetricDomain: getSymmetricDomain,\n  isDomainComponent: isDomainComponent\n};","map":{"version":3,"names":["_includes","_isFunction","_sortedUniq","_isPlainObject","_flatten","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Object","prototype","toString","call","Array","from","isArray","i","arr2","length","React","Data","Scale","Helpers","Collection","cleanDomain","domain","props","axis","scaleType","getScaleType","rules","dom","almostZero","Number","MAX_SAFE_INTEGER","domainOne","domainTwo","getDomainPadding","formatPadding","padding","left","right","domainPadding","getFlatData","dataset","map","datum","concat","undefined","getExtremeFromData","type","arguments","getExtreme","Math","max","apply","min","initialValue","Infinity","containsDate","result","reduce","memo","current0","current1","current","Date","padDomain","minDomain","getMinFromProps","maxDomain","getMaxFromProps","getMinValue","getMaxValue","currentAxis","getCurrentAxis","horizontal","range","getRange","rangeExtent","abs","initialPadding","singleQuadrantDomainPadding","adjust","val","coerce","adjustedDomain","valueOf","finalPadding","paddedDomain","finalDomain","getDomainFromMinMax","createDomainFunction","getDomainFromDataFunction","formatDomainFunction","getDomainFromData","formatDomain","propsDomain","getDomainFromProps","categories","getCategories","getDomainFromCategories","getDomain","polar","_props$startAngle","startAngle","_props$endAngle","endAngle","stringArray","containsStrings","getStringsFromCategories","stringMap","string","index","categoryValues","value","categoryDomain","getSymmetricDomain","getData","_props$startAngle2","_props$endAngle2","getSinglePointDomain","verySmallNumber","pow","verySmallDate","minVal","maxVal","getDomainWithZero","y0Min","_y0","ensureZero","defaultMin","maxDomainProp","minDomainProp","getDomainFunction","values","processedData","sort","a","b","step","isDomainComponent","component","getRole","child","role","children","Children","toArray","whitelist"],"sources":["/root/experiment/nova-explorer/node_modules/victory-core/es/victory-util/domain.js"],"sourcesContent":["import _includes from \"lodash/includes\";\nimport _isFunction from \"lodash/isFunction\";\nimport _sortedUniq from \"lodash/sortedUniq\";\nimport _isPlainObject from \"lodash/isPlainObject\";\nimport _flatten from \"lodash/flatten\";\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\n/* eslint-disable func-style */\n\n/* eslint-disable no-use-before-define */\nimport React from \"react\";\nimport Data from \"./data\";\nimport Scale from \"./scale\";\nimport Helpers from \"./helpers\";\nimport Collection from \"./collection\"; // Private Methods\n\nfunction cleanDomain(domain, props, axis) {\n  var scaleType = Scale.getScaleType(props, axis);\n\n  if (scaleType !== \"log\") {\n    return domain;\n  }\n\n  var rules = function (dom) {\n    var almostZero = dom[0] < 0 || dom[1] < 0 ? -1 / Number.MAX_SAFE_INTEGER : 1 / Number.MAX_SAFE_INTEGER;\n    var domainOne = dom[0] === 0 ? almostZero : dom[0];\n    var domainTwo = dom[1] === 0 ? almostZero : dom[1];\n    return [domainOne, domainTwo];\n  };\n\n  return rules(domain);\n}\n\nfunction getDomainPadding(props, axis) {\n  var formatPadding = function (padding) {\n    return Array.isArray(padding) ? {\n      left: padding[0],\n      right: padding[1]\n    } : {\n      left: padding,\n      right: padding\n    };\n  };\n\n  return _isPlainObject(props.domainPadding) ? formatPadding(props.domainPadding[axis]) : formatPadding(props.domainPadding);\n}\n\nfunction getFlatData(dataset, axis) {\n  return _flatten(dataset).map(function (datum) {\n    return datum[\"_\".concat(axis)] && datum[\"_\".concat(axis)][1] !== undefined ? datum[\"_\".concat(axis)][1] : datum[\"_\".concat(axis)];\n  });\n}\n\nfunction getExtremeFromData(dataset, axis) {\n  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"min\";\n\n  var getExtreme = function (arr) {\n    return type === \"max\" ? Math.max.apply(Math, _toConsumableArray(arr)) : Math.min.apply(Math, _toConsumableArray(arr));\n  };\n\n  var initialValue = type === \"max\" ? -Infinity : Infinity;\n  var containsDate = false;\n\n  var result = _flatten(dataset).reduce(function (memo, datum) {\n    var current0 = datum[\"_\".concat(axis, \"0\")] !== undefined ? datum[\"_\".concat(axis, \"0\")] : datum[\"_\".concat(axis)];\n    var current1 = datum[\"_\".concat(axis, \"1\")] !== undefined ? datum[\"_\".concat(axis, \"1\")] : datum[\"_\".concat(axis)];\n    var current = getExtreme([current0, current1]);\n    containsDate = containsDate || current0 instanceof Date || current1 instanceof Date;\n    return getExtreme([memo, current]);\n  }, initialValue);\n\n  return containsDate ? new Date(result) : result;\n} //eslint-disable-next-line max-statements\n\n\nfunction padDomain(domain, props, axis) {\n  if (!props.domainPadding) {\n    return domain;\n  }\n\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n  var padding = getDomainPadding(props, axis);\n\n  if (!padding.left && !padding.right) {\n    return domain;\n  }\n\n  var min = Collection.getMinValue(domain);\n  var max = Collection.getMaxValue(domain);\n  var currentAxis = Helpers.getCurrentAxis(axis, props.horizontal);\n  var range = Helpers.getRange(props, currentAxis);\n  var rangeExtent = Math.abs(range[0] - range[1]); // Naive initial padding calculation\n\n  var initialPadding = {\n    left: Math.abs(max - min) * padding.left / rangeExtent,\n    right: Math.abs(max - min) * padding.right / rangeExtent\n  };\n  var singleQuadrantDomainPadding = _isPlainObject(props.singleQuadrantDomainPadding) ? props.singleQuadrantDomainPadding[axis] : props.singleQuadrantDomainPadding;\n\n  var adjust = function (val, type) {\n    if (singleQuadrantDomainPadding === false) {\n      return val;\n    }\n\n    var coerce = type === \"min\" && min >= 0 && val <= 0 || type === \"max\" && max <= 0 && val >= 0;\n    return coerce ? 0 : val;\n  }; // Adjust the domain by the initial padding\n\n\n  var adjustedDomain = {\n    min: adjust(min.valueOf() - initialPadding.left, \"min\"),\n    max: adjust(max.valueOf() + initialPadding.right, \"max\")\n  }; // re-calculate padding, taking the adjusted domain into account\n\n  var finalPadding = {\n    left: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.left / rangeExtent,\n    right: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.right / rangeExtent\n  }; // Adjust the domain by the final padding\n\n  var paddedDomain = {\n    min: adjust(min.valueOf() - finalPadding.left, \"min\"),\n    max: adjust(max.valueOf() + finalPadding.right, \"max\")\n  }; // default to minDomain / maxDomain if they exist\n\n  var finalDomain = {\n    min: minDomain !== undefined ? minDomain : paddedDomain.min,\n    max: maxDomain !== undefined ? maxDomain : paddedDomain.max\n  };\n  return min instanceof Date || max instanceof Date ? getDomainFromMinMax(new Date(finalDomain.min), new Date(finalDomain.max)) : getDomainFromMinMax(finalDomain.min, finalDomain.max);\n} // Public Methods\n\n/**\n * Returns a getDomain function\n * @param {Function} getDomainFromDataFunction: a function that takes props and axis and\n * returns a domain based on data\n * @param {Function} formatDomainFunction: a function that takes domain, props, and axis and\n * returns a formatted domain\n * @returns {Function} a function that takes props and axis and returns a formatted domain\n */\n\n\nfunction createDomainFunction(getDomainFromDataFunction, formatDomainFunction) {\n  getDomainFromDataFunction = _isFunction(getDomainFromDataFunction) ? getDomainFromDataFunction : getDomainFromData;\n  formatDomainFunction = _isFunction(formatDomainFunction) ? formatDomainFunction : formatDomain;\n  return function (props, axis) {\n    var propsDomain = getDomainFromProps(props, axis);\n\n    if (propsDomain) {\n      return formatDomainFunction(propsDomain, props, axis);\n    }\n\n    var categories = Data.getCategories(props, axis);\n    var domain = categories ? getDomainFromCategories(props, axis, categories) : getDomainFromDataFunction(props, axis);\n    return domain ? formatDomainFunction(domain, props, axis) : undefined;\n  };\n}\n/**\n * Returns a formatted domain.\n * @param {Array} domain: a domain in the form of a two element array\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} a domain in the form of a two element array\n */\n\n\nfunction formatDomain(domain, props, axis) {\n  return cleanDomain(padDomain(domain, props, axis), props, axis);\n}\n/**\n * Returns a domain for a given axis based on props, category, or data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} the domain for the given axis\n */\n\n\nfunction getDomain(props, axis) {\n  return createDomainFunction()(props, axis);\n}\n/**\n * Returns a domain based on categories if they exist\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @param {Array} categories: an array of categories corresponding to a given axis\n * @returns {Array|undefined} returns a domain from categories or undefined\n */\n\n\nfunction getDomainFromCategories(props, axis, categories) {\n  categories = categories || Data.getCategories(props, axis);\n  var polar = props.polar,\n      _props$startAngle = props.startAngle,\n      startAngle = _props$startAngle === void 0 ? 0 : _props$startAngle,\n      _props$endAngle = props.endAngle,\n      endAngle = _props$endAngle === void 0 ? 360 : _props$endAngle;\n\n  if (!categories) {\n    return undefined;\n  }\n\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n  var stringArray = Collection.containsStrings(categories) ? Data.getStringsFromCategories(props, axis) : [];\n  var stringMap = stringArray.length === 0 ? null : stringArray.reduce(function (memo, string, index) {\n    memo[string] = index + 1;\n    return memo;\n  }, {});\n  var categoryValues = stringMap ? categories.map(function (value) {\n    return stringMap[value];\n  }) : categories;\n  var min = minDomain !== undefined ? minDomain : Collection.getMinValue(categoryValues);\n  var max = maxDomain !== undefined ? maxDomain : Collection.getMaxValue(categoryValues);\n  var categoryDomain = getDomainFromMinMax(min, max);\n  return polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? getSymmetricDomain(categoryDomain, categoryValues) : categoryDomain;\n}\n/**\n * Returns a domain from a dataset for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @param {Array} dataset: an array of data\n * @returns {Array} the domain based on data\n */\n\n\nfunction getDomainFromData(props, axis, dataset) {\n  dataset = dataset || Data.getData(props);\n  var polar = props.polar,\n      _props$startAngle2 = props.startAngle,\n      startAngle = _props$startAngle2 === void 0 ? 0 : _props$startAngle2,\n      _props$endAngle2 = props.endAngle,\n      endAngle = _props$endAngle2 === void 0 ? 360 : _props$endAngle2;\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n\n  if (dataset.length < 1) {\n    return minDomain !== undefined && maxDomain !== undefined ? getDomainFromMinMax(minDomain, maxDomain) : undefined;\n  }\n\n  var min = minDomain !== undefined ? minDomain : getExtremeFromData(dataset, axis, \"min\");\n  var max = maxDomain !== undefined ? maxDomain : getExtremeFromData(dataset, axis, \"max\");\n  var domain = getDomainFromMinMax(min, max);\n  return polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? getSymmetricDomain(domain, getFlatData(dataset, axis)) : domain;\n}\n/**\n * Returns a domain in the form of a two element array given a min and max value.\n * @param {Number|Date} min: the props object\n * @param {Number|Date} max: the current axis\n * @returns {Array} the minDomain based on props\n */\n\n\nfunction getDomainFromMinMax(min, max) {\n  var getSinglePointDomain = function (val) {\n    // d3-scale does not properly resolve very small differences.\n    // eslint-disable-next-line no-magic-numbers\n    var verySmallNumber = val === 0 ? 2 * Math.pow(10, -10) : Math.pow(10, -10);\n    var verySmallDate = 1;\n    var minVal = val instanceof Date ? new Date(+val - verySmallDate) : +val - verySmallNumber;\n    var maxVal = val instanceof Date ? new Date(+val + verySmallDate) : +val + verySmallNumber;\n    return val === 0 ? [0, maxVal] : [minVal, maxVal];\n  };\n\n  return +min === +max ? getSinglePointDomain(max) : [min, max];\n}\n/**\n * Returns a the domain for a given axis if domain is given in props\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array|undefined} the domain based on props\n */\n\n\nfunction getDomainFromProps(props, axis) {\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n\n  if (_isPlainObject(props.domain) && props.domain[axis]) {\n    return props.domain[axis];\n  } else if (Array.isArray(props.domain)) {\n    return props.domain;\n  } else if (minDomain !== undefined && maxDomain !== undefined) {\n    return getDomainFromMinMax(minDomain, maxDomain);\n  }\n\n  return undefined;\n}\n/**\n * Returns a domain for a given axis. This method forces the domain to include\n * zero unless the domain is explicitly specified in props.\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} the domain for the given axis\n */\n\n\nfunction getDomainWithZero(props, axis) {\n  var propsDomain = getDomainFromProps(props, axis);\n\n  if (propsDomain) {\n    return propsDomain;\n  }\n\n  var dataset = Data.getData(props);\n  var y0Min = dataset.reduce(function (min, datum) {\n    return datum._y0 < min ? datum._y0 : min;\n  }, Infinity);\n\n  var ensureZero = function (domain) {\n    if (axis === \"x\") {\n      return domain;\n    }\n\n    var defaultMin = y0Min !== Infinity ? y0Min : 0;\n    var maxDomainProp = getMaxFromProps(props, axis);\n    var minDomainProp = getMinFromProps(props, axis);\n    var max = maxDomainProp !== undefined ? maxDomainProp : Collection.getMaxValue(domain, defaultMin);\n    var min = minDomainProp !== undefined ? minDomainProp : Collection.getMinValue(domain, defaultMin);\n    return getDomainFromMinMax(min, max);\n  };\n\n  var getDomainFunction = function () {\n    return getDomainFromData(props, axis, dataset);\n  };\n\n  var formatDomainFunction = function (domain) {\n    return formatDomain(ensureZero(domain), props, axis);\n  };\n\n  return createDomainFunction(getDomainFunction, formatDomainFunction)(props, axis);\n}\n/**\n * Returns the maxDomain from props if it exists\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Number|undefined} the maxDomain based on props\n */\n\n\nfunction getMaxFromProps(props, axis) {\n  if (_isPlainObject(props.maxDomain) && props.maxDomain[axis] !== undefined) {\n    return props.maxDomain[axis];\n  }\n\n  return typeof props.maxDomain === \"number\" ? props.maxDomain : undefined;\n}\n/**\n * Returns the minDomain from props if it exists\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Number|undefined} the minDomain based on props\n */\n\n\nfunction getMinFromProps(props, axis) {\n  if (_isPlainObject(props.minDomain) && props.minDomain[axis] !== undefined) {\n    return props.minDomain[axis];\n  }\n\n  return typeof props.minDomain === \"number\" ? props.minDomain : undefined;\n}\n/**\n * Returns a symmetrically padded domain for polar charts\n * @param {Array} domain: the original domain\n * @param {Array} values: a flat array of values corresponding to either tickValues, or data values\n * for a given dimension i.e. only x values.\n * @returns {Array} the symmetric domain\n */\n\n\nfunction getSymmetricDomain(domain, values) {\n  var processedData = _sortedUniq(values.sort(function (a, b) {\n    return a - b;\n  }));\n\n  var step = processedData[1] - processedData[0];\n  return [domain[0], domain[1] + step];\n}\n/**\n * Checks whether a given component can be used to calculate domain\n * @param {Component} component: a React component instance\n * @returns {Boolean} Returns true if the given component has a role included in the whitelist\n */\n\n\nfunction isDomainComponent(component) {\n  var getRole = function (child) {\n    return child && child.type ? child.type.role : \"\";\n  };\n\n  var role = getRole(component);\n\n  if (role === \"portal\") {\n    var children = React.Children.toArray(component.props.children);\n    role = children.length ? getRole(children[0]) : \"\";\n  }\n\n  var whitelist = [\"area\", \"axis\", \"bar\", \"boxplot\", \"candlestick\", \"errorbar\", \"group\", \"line\", \"pie\", \"scatter\", \"stack\", \"voronoi\"];\n  return _includes(whitelist, role);\n}\n\nexport default {\n  createDomainFunction: createDomainFunction,\n  formatDomain: formatDomain,\n  getDomain: getDomain,\n  getDomainFromCategories: getDomainFromCategories,\n  getDomainFromData: getDomainFromData,\n  getDomainFromMinMax: getDomainFromMinMax,\n  getDomainFromProps: getDomainFromProps,\n  getDomainWithZero: getDomainWithZero,\n  getMaxFromProps: getMaxFromProps,\n  getMinFromProps: getMinFromProps,\n  getSymmetricDomain: getSymmetricDomain,\n  isDomainComponent: isDomainComponent\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}