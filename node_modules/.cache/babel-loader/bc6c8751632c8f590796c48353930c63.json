{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport { stringify, parse as parseQueryString } from 'query-string';\n/**\n * remove query params that are nully or an empty strings.\n * note: these values are assumed to be already encoded as strings.\n */\nfunction filterNully(query) {\n  var filteredQuery = Object.keys(query).reduce(function (queryAccumulator, queryParam) {\n    // get encoded value for this param\n    var encodedValue = query[queryParam];\n    // if it isn't null or empty string, add it to the accumulated obj\n    if (encodedValue != null && encodedValue !== '') {\n      queryAccumulator[queryParam] = encodedValue;\n    }\n    return queryAccumulator;\n  }, {});\n  return filteredQuery;\n}\n/**\n * Update a location, wiping out parameters not included in encodedQuery\n */\nexport function updateLocation(encodedQuery, location) {\n  var encodedSearchString = stringify(filterNully(encodedQuery));\n  var newLocation = __assign({}, location, {\n    key: \"\" + Date.now(),\n    search: encodedSearchString.length ? \"?\" + encodedSearchString : '',\n    query: encodedQuery\n  });\n  return newLocation;\n}\n/**\n * Update a location while retaining existing parameters\n */\nexport function updateInLocation(encodedQueryReplacements, location) {\n  // if a query is there, use it, otherwise parse the search string\n  var currQuery = location.query || parseQueryString(location.search);\n  var newQuery = __assign({}, currQuery, encodedQueryReplacements);\n  return updateLocation(filterNully(newQuery), location);\n}","map":{"version":3,"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","stringify","parse","parseQueryString","filterNully","query","filteredQuery","keys","reduce","queryAccumulator","queryParam","encodedValue","updateLocation","encodedQuery","location","encodedSearchString","newLocation","key","Date","now","search","updateInLocation","encodedQueryReplacements","currQuery","newQuery"],"sources":["/root/experiment/nova-explorer/node_modules/serialize-query-params/esm/updateLocation.js"],"sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { stringify, parse as parseQueryString } from 'query-string';\n/**\n * remove query params that are nully or an empty strings.\n * note: these values are assumed to be already encoded as strings.\n */\nfunction filterNully(query) {\n    var filteredQuery = Object.keys(query).reduce(function (queryAccumulator, queryParam) {\n        // get encoded value for this param\n        var encodedValue = query[queryParam];\n        // if it isn't null or empty string, add it to the accumulated obj\n        if (encodedValue != null && encodedValue !== '') {\n            queryAccumulator[queryParam] = encodedValue;\n        }\n        return queryAccumulator;\n    }, {});\n    return filteredQuery;\n}\n/**\n * Update a location, wiping out parameters not included in encodedQuery\n */\nexport function updateLocation(encodedQuery, location) {\n    var encodedSearchString = stringify(filterNully(encodedQuery));\n    var newLocation = __assign({}, location, { key: \"\" + Date.now(), search: encodedSearchString.length ? \"?\" + encodedSearchString : '', query: encodedQuery });\n    return newLocation;\n}\n/**\n * Update a location while retaining existing parameters\n */\nexport function updateInLocation(encodedQueryReplacements, location) {\n    // if a query is there, use it, otherwise parse the search string\n    var currQuery = location.query || parseQueryString(location.search);\n    var newQuery = __assign({}, currQuery, encodedQueryReplacements);\n    return updateLocation(filterNully(newQuery), location);\n}\n"],"mappings":"AAAA,IAAIA,QAAQ,GAAI,IAAI,IAAI,IAAI,CAACA,QAAQ,IAAK,YAAY;EAClDA,QAAQ,GAAGC,MAAM,CAACC,MAAM,IAAI,UAASC,CAAC,EAAE;IACpC,KAAK,IAAIC,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGC,SAAS,CAACC,MAAM,EAAEH,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;MACjDD,CAAC,GAAGG,SAAS,CAACF,CAAC,CAAC;MAChB,KAAK,IAAII,CAAC,IAAIL,CAAC;QAAE,IAAIH,MAAM,CAACS,SAAS,CAACC,cAAc,CAACC,IAAI,CAACR,CAAC,EAAEK,CAAC,CAAC,EAC3DN,CAAC,CAACM,CAAC,CAAC,GAAGL,CAAC,CAACK,CAAC,CAAC;MAAC;IACpB;IACA,OAAON,CAAC;EACZ,CAAC;EACD,OAAOH,QAAQ,CAACa,KAAK,CAAC,IAAI,EAAEN,SAAS,CAAC;AAC1C,CAAC;AACD,SAASO,SAAS,EAAEC,KAAK,IAAIC,gBAAgB,QAAQ,cAAc;AACnE;AACA;AACA;AACA;AACA,SAASC,WAAWA,CAACC,KAAK,EAAE;EACxB,IAAIC,aAAa,GAAGlB,MAAM,CAACmB,IAAI,CAACF,KAAK,CAAC,CAACG,MAAM,CAAC,UAAUC,gBAAgB,EAAEC,UAAU,EAAE;IAClF;IACA,IAAIC,YAAY,GAAGN,KAAK,CAACK,UAAU,CAAC;IACpC;IACA,IAAIC,YAAY,IAAI,IAAI,IAAIA,YAAY,KAAK,EAAE,EAAE;MAC7CF,gBAAgB,CAACC,UAAU,CAAC,GAAGC,YAAY;IAC/C;IACA,OAAOF,gBAAgB;EAC3B,CAAC,EAAE,CAAC,CAAC,CAAC;EACN,OAAOH,aAAa;AACxB;AACA;AACA;AACA;AACA,OAAO,SAASM,cAAcA,CAACC,YAAY,EAAEC,QAAQ,EAAE;EACnD,IAAIC,mBAAmB,GAAGd,SAAS,CAACG,WAAW,CAACS,YAAY,CAAC,CAAC;EAC9D,IAAIG,WAAW,GAAG7B,QAAQ,CAAC,CAAC,CAAC,EAAE2B,QAAQ,EAAE;IAAEG,GAAG,EAAE,EAAE,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;IAAEC,MAAM,EAAEL,mBAAmB,CAACpB,MAAM,GAAG,GAAG,GAAGoB,mBAAmB,GAAG,EAAE;IAAEV,KAAK,EAAEQ;EAAa,CAAC,CAAC;EAC5J,OAAOG,WAAW;AACtB;AACA;AACA;AACA;AACA,OAAO,SAASK,gBAAgBA,CAACC,wBAAwB,EAAER,QAAQ,EAAE;EACjE;EACA,IAAIS,SAAS,GAAGT,QAAQ,CAACT,KAAK,IAAIF,gBAAgB,CAACW,QAAQ,CAACM,MAAM,CAAC;EACnE,IAAII,QAAQ,GAAGrC,QAAQ,CAAC,CAAC,CAAC,EAAEoC,SAAS,EAAED,wBAAwB,CAAC;EAChE,OAAOV,cAAc,CAACR,WAAW,CAACoB,QAAQ,CAAC,EAAEV,QAAQ,CAAC;AAC1D"},"metadata":{},"sourceType":"module"}