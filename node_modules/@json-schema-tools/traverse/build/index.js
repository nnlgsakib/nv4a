"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultOptions = void 0;
exports.defaultOptions = {
    skipFirstMutation: false,
    mutable: false,
    bfs: false,
};
var jsonPathStringify = function (s) {
    return s.map(function (i) { return i === "" ? i.toString() : ("/" + i.toString()); }).join("");
};
var isCycle = function (s, recursiveStack) {
    var foundInRecursiveStack = recursiveStack.find(function (recSchema) { return recSchema === s; });
    if (foundInRecursiveStack) {
        return foundInRecursiveStack;
    }
    return false;
};
/**
 * Traverse all subschema of a schema, calling the mutator function with each.
 * The mutator is called on leaf nodes first.
 *
 * @param schema the schema to traverse
 * @param mutation the function to pass each node in the subschema tree.
 * @param traverseOptions a set of options for traversal.
 * @param depth For internal use. Tracks the current recursive depth in the tree. This is used to implement
 *              some of the options.
 *
 */
function traverse(schema, mutation, traverseOptions, depth, recursiveStack, pathStack, prePostMap) {
    if (traverseOptions === void 0) { traverseOptions = exports.defaultOptions; }
    if (depth === void 0) { depth = 0; }
    if (recursiveStack === void 0) { recursiveStack = []; }
    if (pathStack === void 0) { pathStack = []; }
    if (prePostMap === void 0) { prePostMap = []; }
    var isRootOfCycle = false;
    var opts = __assign(__assign({}, exports.defaultOptions), traverseOptions); // would be nice to make an 'entry' func when we get around to optimizations
    // booleans are a bit messed. Since all other schemas are objects (non-primitive type
    // which gets a new address in mem) for each new JS refer to one of 2 memory addrs, and
    // thus adding it to the recursive stack will prevent it from being explored if the
    // boolean is seen in a further nested schema.
    if (depth === 0) {
        pathStack = [""];
    }
    if (typeof schema === "boolean" || schema instanceof Boolean) {
        if (opts.skipFirstMutation === true && depth === 0) {
            return schema;
        }
        else {
            return mutation(schema, false, jsonPathStringify(pathStack));
        }
    }
    var mutableSchema = schema;
    if (opts.mutable === false) {
        mutableSchema = __assign({}, schema);
    }
    if (opts.bfs === true) {
        if (opts.skipFirstMutation === false || depth !== 0) {
            mutableSchema = mutation(mutableSchema, false, jsonPathStringify(pathStack));
        }
    }
    recursiveStack.push(schema);
    prePostMap.push([schema, mutableSchema]);
    var rec = function (s, path) {
        var foundCycle = isCycle(s, recursiveStack);
        if (foundCycle) {
            if (foundCycle === schema) {
                isRootOfCycle = true;
            }
            // if the cycle is a ref to the root schema && skipFirstMutation is try we need to call mutate.
            // If we don't, it will never happen.
            if (opts.skipFirstMutation === true && foundCycle === recursiveStack[0]) {
                return mutation(s, true, jsonPathStringify(path));
            }
            var _a = prePostMap.find(function (_a) {
                var orig = _a[0];
                return foundCycle === orig;
            }), cycledMutableSchema = _a[1];
            return cycledMutableSchema;
        }
        return traverse(s, mutation, traverseOptions, depth + 1, recursiveStack, path, prePostMap);
    };
    if (schema.anyOf) {
        mutableSchema.anyOf = schema.anyOf.map(function (x, i) {
            var result = rec(x, __spreadArrays(pathStack, ["anyOf", i.toString()]));
            return result;
        });
    }
    else if (schema.allOf) {
        mutableSchema.allOf = schema.allOf.map(function (x, i) {
            var result = rec(x, __spreadArrays(pathStack, ["allOf", i.toString()]));
            return result;
        });
    }
    else if (schema.oneOf) {
        mutableSchema.oneOf = schema.oneOf.map(function (x, i) {
            var result = rec(x, __spreadArrays(pathStack, ["oneOf", i.toString()]));
            return result;
        });
    }
    else {
        var itemsIsSingleSchema = false;
        if (schema.items) {
            if (schema.items instanceof Array) {
                mutableSchema.items = schema.items.map(function (x, i) {
                    var result = rec(x, __spreadArrays(pathStack, ["items", i.toString()]));
                    return result;
                });
            }
            else {
                var foundCycle_1 = isCycle(schema.items, recursiveStack);
                if (foundCycle_1) {
                    if (foundCycle_1 === schema) {
                        isRootOfCycle = true;
                    }
                    if (opts.skipFirstMutation === true && foundCycle_1 === recursiveStack[0]) {
                        mutableSchema.items = mutation(schema.items, true, jsonPathStringify(pathStack));
                    }
                    else {
                        var _a = prePostMap.find(function (_a) {
                            var orig = _a[0];
                            return foundCycle_1 === orig;
                        }), cycledMutableSchema = _a[1];
                        mutableSchema.items = cycledMutableSchema;
                    }
                }
                else {
                    itemsIsSingleSchema = true;
                    mutableSchema.items = traverse(schema.items, mutation, traverseOptions, depth + 1, recursiveStack, pathStack, prePostMap);
                }
            }
        }
        if (schema.additionalItems !== undefined && !!schema.additionalItems === true && !itemsIsSingleSchema) {
            mutableSchema.additionalItems = rec(schema.additionalItems, __spreadArrays(pathStack, ["additionalItems"]));
        }
        if (schema.properties !== undefined) {
            var sProps_1 = schema.properties;
            var mutableProps_1 = {};
            Object.keys(schema.properties).forEach(function (schemaPropKey) {
                mutableProps_1[schemaPropKey] = rec(sProps_1[schemaPropKey], __spreadArrays(pathStack, ["properties", schemaPropKey.toString()]));
            });
            mutableSchema.properties = mutableProps_1;
        }
        if (schema.patternProperties !== undefined) {
            var sProps_2 = schema.patternProperties;
            var mutableProps_2 = {};
            Object.keys(schema.patternProperties).forEach(function (regex) {
                mutableProps_2[regex] = rec(sProps_2[regex], __spreadArrays(pathStack, ["patternProperties", regex.toString()]));
            });
            mutableSchema.patternProperties = mutableProps_2;
        }
        if (schema.additionalProperties !== undefined && !!schema.additionalProperties === true) {
            mutableSchema.additionalProperties = rec(schema.additionalProperties, __spreadArrays(pathStack, ["additionalProperties"]));
        }
    }
    if (opts.skipFirstMutation === true && depth === 0) {
        return mutableSchema;
    }
    if (opts.bfs === true) {
        return mutableSchema;
    }
    else {
        return mutation(mutableSchema, isRootOfCycle, jsonPathStringify(pathStack));
    }
}
exports.default = traverse;
