"use strict";
/** @module semantic-release-gh-pages-plugin */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var git_url_parse_1 = tslib_1.__importDefault(require("git-url-parse"));
var lodash_1 = require("lodash");
var read_pkg_1 = tslib_1.__importDefault(require("read-pkg"));
var sync_request_1 = tslib_1.__importDefault(require("sync-request"));
var util_1 = require("./util");
var defaults_1 = require("./defaults");
exports.DEFAULT_BRANCH = defaults_1.DEFAULT_BRANCH;
exports.DEFAULT_DST = defaults_1.DEFAULT_DST;
exports.DEFAULT_MSG = defaults_1.DEFAULT_MSG;
exports.DEFAULT_SRC = defaults_1.DEFAULT_SRC;
exports.PLUGIN_PATH = defaults_1.PLUGIN_PATH;
exports.DEFAULT_ENTERPRISE = defaults_1.DEFAULT_ENTERPRISE;
exports.DEFAULT_PULL_TAGS_BRANCH = defaults_1.DEFAULT_PULL_TAGS_BRANCH;
var gitUrlParse = util_1.catchToSmth(git_url_parse_1.default, {});
exports.GITIO_REPO_PATTERN = /^https:\/\/git\.io\/[A-Za-z0-9-]+$/;
/**
 * @private
 */
exports.extractRepoName = function (repoUrl) {
    return gitUrlParse(repoUrl).full_name;
};
/**
 * @private
 */
exports.extractRepoDomain = function (repoUrl) {
    return gitUrlParse(repoUrl).resource;
};
/**
 * @private
 */
exports.extractRepoToken = function (repoUrl) {
    var repo = gitUrlParse(repoUrl);
    return repo.token || repo.user;
};
/**
 * @private
 */
exports.getRepoUrl = function (pluginConfig, context) {
    var _a;
    var env = context.env, logger = context.logger;
    var urlFromEnv = getRepoUrlFromEnv(env);
    var urlFromStepOpts = pluginConfig.repositoryUrl;
    var urlFromOpts = ((_a = context === null || context === void 0 ? void 0 : context.options) === null || _a === void 0 ? void 0 : _a.repositoryUrl) || '';
    var urlFromPackage = exports.getUrlFromPackage();
    var url = urlFromStepOpts || urlFromOpts || urlFromEnv || urlFromPackage;
    if (process.env.DEBUG) {
        logger.log('getRepoUrl:');
        logger.log('urlFromEnv=', urlFromEnv);
        logger.log('urlFromStepOpts=', urlFromStepOpts);
        logger.log('urlFromOpts=', urlFromOpts);
        logger.log('urlFromPackage', urlFromPackage);
        logger.log('url=', url);
    }
    if (exports.GITIO_REPO_PATTERN.test(url)) {
        var res = sync_request_1.default('GET', urlFromOpts, { followRedirects: false, timeout: 5000 });
        return res.headers.location;
    }
    return url;
};
/**
 * @private
 */
var getRepoUrlFromEnv = function (env) { return env.REPO_URL; };
/**
 * @private
 */
exports.getUrlFromPackage = function () {
    var _a;
    var pkg = read_pkg_1.default.sync();
    return String(((_a = pkg === null || pkg === void 0 ? void 0 : pkg.repository) === null || _a === void 0 ? void 0 : _a.url) || (pkg === null || pkg === void 0 ? void 0 : pkg.repository) || '');
};
/**
 * @private
 */
exports.getToken = function (env, repoUrl) { return env.GH_TOKEN || env.GITHUB_TOKEN || exports.extractRepoToken(repoUrl); };
/**
 * @private
 */
exports.getRepo = function (pluginConfig, context, enterprise) {
    var env = context.env, logger = context.logger;
    var repoUrl = exports.getRepoUrl(pluginConfig, context);
    var repoName = exports.extractRepoName(repoUrl);
    var repoDomain = exports.extractRepoDomain(repoUrl);
    var token = exports.getToken(env, repoUrl);
    var url = "https://" + token + "@" + repoDomain + "/" + repoName + ".git";
    if (process.env.DEBUG) {
        logger.log('getRepo:');
        logger.log('repoUrl=', repoUrl);
        logger.log('repoName=', repoName);
        logger.log('repoDomain=', repoDomain);
        logger.log('has token=', !!token);
        logger.log('enterprise=', enterprise);
    }
    if (repoDomain === 'github.com' && repoName) {
        return url;
    }
    if (enterprise) {
        return repoName
            ? url
            : repoUrl;
    }
};
/**
 * @private
 */
exports.resolveConfig = function (pluginConfig, context, path, step) {
    if (path === void 0) { path = defaults_1.PLUGIN_PATH; }
    var env = context.env, logger = context.logger;
    var opts = exports.resolveOptions(pluginConfig, context, path, step);
    var enterprise = Boolean(opts.enterprise || pluginConfig.enterprise || defaults_1.DEFAULT_ENTERPRISE);
    var repo = exports.getRepo(pluginConfig, context, enterprise);
    var repoUrl = exports.getRepoUrl(pluginConfig, context);
    var token = exports.getToken(env, repoUrl);
    var pullTagsBranch = util_1.anyDefined(opts.pullTagsBranch, opts._branch, defaults_1.DEFAULT_PULL_TAGS_BRANCH);
    if (process.env.DEBUG) {
        logger.log('resolveConfig args:');
        logger.log('context=', JSON.stringify(lodash_1.omit(context, 'env.GH_TOKEN', 'env.GITHUB_TOKEN'), null, 2));
        logger.log('pluginConfig=', JSON.stringify(pluginConfig, null, 2));
        logger.log('path=', path);
        logger.log('step=', step);
        logger.log('pullTagsBranch=', pullTagsBranch);
    }
    return {
        src: opts.src || defaults_1.DEFAULT_SRC,
        dst: opts.dst || defaults_1.DEFAULT_DST,
        msg: opts.msg || defaults_1.DEFAULT_MSG,
        branch: opts.branch || defaults_1.DEFAULT_BRANCH,
        enterprise: enterprise,
        token: token,
        repo: repo,
        pullTagsBranch: pullTagsBranch
    };
};
/**
 * @private
 */
exports.resolveOptions = function (pluginConfig, context, path, step) {
    if (path === void 0) { path = defaults_1.PLUGIN_PATH; }
    var options = context.options;
    var base = lodash_1.omit(pluginConfig, 'branch');
    var extra = step && options[step] && lodash_1.castArray(options[step])
        .map(function (config) {
        if (Array.isArray(config)) {
            var path_1 = config[0], opts = config[1];
            return tslib_1.__assign(tslib_1.__assign({}, opts), { path: path_1 });
        }
        return config;
    })
        .find(function (config) { return (config === null || config === void 0 ? void 0 : config.path) === path; }) || {};
    return tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, base), extra), { _branch: pluginConfig.branch });
};
